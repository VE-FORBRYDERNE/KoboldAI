--------------------------------------------------------------------------------
--
-- Penlight 1.11.0-1
-- https://github.com/lunarmodules/Penlight
-- License: MIT
-- Contains all Penlight modules except pl.dir, pl.file and pl.path.
--
--------------------------------------------------------------------------------
--
-- This file was compiled by downloading the aforementioned version of Penlight
-- and then running lua-amalg
-- (https://github.com/siffiejoe/lua-amalg/tree/087e400aa78acb91679f75572b7eac719ca604f4):
--
--     lua amalg.lua -o penlight.lua pl pl.Set pl.app pl.array2d pl.class pl.compat pl.comprehension pl.config pl.data pl.func pl.import_into pl.input pl.lapp pl.lexer pl.luabalanced pl.operator pl.permute pl.pretty pl.seq pl.sip pl.strict pl.stringio pl.stringx pl.tablex pl.template pl.test pl.text pl.types pl.url pl.utils pl.xml pl.Date pl.List pl.Map pl.MultiMap pl.OrderedMap
--
-- then running luamin
-- (https://www.npmjs.com/package/luamin/v/1.0.4)
-- on the result.
--
--------------------------------------------------------------------------------
--
-- Copyright (C) 2009-2016 Steve Donovan, David Manura.
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
-- ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
-- TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
-- PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
-- SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
-- ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-- ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
-- OR OTHER DEALINGS IN THE SOFTWARE.
--
--------------------------------------------------------------------------------
do local _ENV=_ENV;package.preload["pl"]=function(...)local a=_G.arg;require'pl.import_into'(_G)if rawget(_G,'PENLIGHT_STRICT')then require'pl.strict'end end end;do local _ENV=_ENV;package.preload["pl.Date"]=function(...)local a=_G.arg;local b=require'pl.class'local c,d=os.time,os.date;local e=require'pl.stringx'local f=require'pl.utils'local g,h=f.assert_arg,f.assert_string;f.raise_deprecation{source="Penlight "..f._VERSION,message="the 'Date' module is deprecated, see https://github.com/lunarmodules/Penlight/issues/285",version_removed="2.0.0",version_deprecated="1.9.2"}local i=b()i.Format=b()function i:_init(j,...)local k;local l=select('#',...)if l>2 then local m={...}local n=j;j={year=n,month=m[1],day=m[2],hour=m[3],min=m[4],sec=m[5]}end;if l==1 then self.utc=select(1,...)==true end;if j==nil or j=='utc'then k=c()self.utc=j=='utc'elseif type(j)=='number'then k=j;if self.utc==nil then self.utc=true end elseif type(j)=='table'then if getmetatable(j)==i then k=j.time;self.utc=j.utc else if not(j.year and j.month)then local o=d('*t')if not j.year and not j.month and not j.day then j.year=o.year;j.month=o.month;j.day=o.day else j.year=j.year or o.year;j.month=j.month or(j.day and o.month or 1)j.day=j.day or 1 end end;j.day=j.day or 1;k=c(j)end else error("bad type for Date constructor: "..type(j),2)end;self:set(k)end;function i:set(j)self.time=j;if self.utc then self.tab=d('!*t',j)else self.tab=d('*t',j)end end;function i.tzone(p)if p==nil then p=c()elseif type(p)=="table"then if getmetatable(p)==i then p=p.time else p=i(p).time end end;local q=d('!*t',p)local r=d('*t',p)r.isdst=false;return os.difftime(c(r),c(q))end;function i:toUTC()local s=i(self)if not self.utc then s.utc=true;s:set(s.time)end;return s end;function i:toLocal()local s=i(self)if self.utc then s.utc=false;s:set(s.time)end;return s end;for t,u in ipairs{'year','month','day','hour','min','sec','yday'}do i[u]=function(self,v)if v then g(1,v,"number")self.tab[u]=v;self:set(c(self.tab))return self else return self.tab[u]end end end;function i:weekday_name(w)return d(w and'%A'or'%a',self.time)end;function i:month_name(w)return d(w and'%B'or'%b',self.time)end;function i:is_weekend()return self.tab.wday==1 or self.tab.wday==7 end;function i:add(j)local x=self.tab.isdst;local y,v=next(j)self.tab[y]=self.tab[y]+v;self:set(c(self.tab))if x~=self.tab.isdst then self.tab.hour=self.tab.hour-(x and 1 or-1)self:set(c(self.tab))end;return self end;function i:last_day()local z=28;local A=self.tab.month;while self.tab.month==A do z=z+1;self:add{day=1}end;self:add{day=-1}return self end;function i:diff(B)local C=self.time-B.time;if C<0 then error("date difference is negative!",2)end;return i.Interval(C)end;function i:__tostring()local D='%Y-%m-%dT%H:%M:%S'if self.utc then D="!"..D end;local j=d(D,self.time)if self.utc then return j..'Z'else local E=self:tzone()if E==0 then return j..'Z'end;local F=E>0 and'+'or'-'local G=math.ceil(E/3600)local A=E%3600/60;if A==0 then return j..('%s%02d'):format(F,G)else return j..('%s%02d:%02d'):format(F,G,A)end end end;function i:__eq(B)return self.time==B.time end;function i:__lt(B)return self.time<B.time end;i.__sub=i.diff;function i:__add(B)local H=i(self)if i.Interval:class_of(B)then B={sec=B.time}end;H:add(B)return H end;i.Interval=b(i)function i.Interval:_init(j)self:set(j)end;function i.Interval:set(j)self.time=j;self.tab=d('!*t',self.time)end;local function I(J)if J>1 then return's 'else return' 'end end;function i.Interval:__tostring()local j,K=self.tab,''local L,A,z=j.year-1970,j.month-1,j.day-1;if L>0 then K=K..L..' year'..I(L)end;if A>0 then K=K..A..' month'..I(A)end;if z>0 then K=K..z..' day'..I(z)end;if L==0 and A==0 then local G=j.hour;if G>0 then K=K..G..' hour'..I(G)end;if j.min>0 then K=K..j.min..' min 'end;if j.sec>0 then K=K..j.sec..' sec 'end end;if K==''then K='zero'end;return K end;local M={d={'day',{true,true}},y={'year',{false,true,false,true}},m={'month',{true,true}},H={'hour',{true,true}},M={'min',{true,true}},S={'sec',{true,true}}}function i.Format:_init(D)if not D then self.fmt='%Y-%m-%d %H:%M:%S'self.outf=self.fmt;self.plain=true;return end;local N=table.insert;local O,P,Q,R='\001','\002','\003','\004'local S,T={},{}local U,V={},{}local W=1;while W<#D do local X=D:sub(W,W)local Y=M[X]if Y then if T[X]then error("field appeared twice: "..X,4)end;T[X]=true;local t,Z=D:find(X..'+',W+1)local _=not t and 1 or Z-W+1;if not Y[2][_]then error("wrong number of fields: "..X,4)end;local a0=_==1 and O..P or O:rep(_)N(U,Q..a0 ..R)N(S,X)if X=='y'then N(V,_==2 and'%y'or'%Y')else N(V,'%'..X)end;W=W+_ else N(U,X)N(V,X)W=W+1 end end;D=f.escape(table.concat(U))D=D:gsub(O,'%%d'):gsub(P,'+'):gsub(Q,'('):gsub(R,')')self.fmt=D;self.outf=table.concat(V)self.vars=S end;local a1;function i.Format:parse(a2)h(1,a2)if self.plain then return a1(a2,self.us)end;local K={a2:match(self.fmt)}if#K==0 then return nil,'cannot parse '..a2 end;local a3={}for W,a4 in ipairs(self.vars)do local a5=M[a4][1]a3[a5]=tonumber(K[W])end;if not(a3.year and a3.month and a3.day)then local a6=i()a3.year=a3.year or a6:year()a3.month=a3.month or a6:month()a3.day=a3.day or a6:day()end;local a7=a3.year;if a7<100 then a3.year=a7+(a7<35 and 2000 or 1999)elseif not a7 then a3.year=1970 end;return i(a3)end;function i.Format:tostring(z)local a8;local D=self.outf;if type(z)=='number'then a8=z else a8=z.time;if z.utc then D='!'..D end end;return d(D,a8)end;function i.Format:US_order(a9)self.us=a9 end;local aa;local ab;local function ac()local ad,ae=ab'2000-12-31',{day=1}aa={}for W=1,12 do ad=ad:last_day()ad:add(ae)local af=ad:month_name():lower()aa[af]=W end end;local function ag(ah)return ah:match'^%a+,*$'~=nil end;local ai=e.isdigit;local function aj(ak,al,am,an)an=an or''local J=tonumber(ak)if not J then error(("%snot a number: '%s'"):format(an,ak))end;if J<al or J>am then error(("%s out of range: %s is not between %d and %d"):format(an,ak,al,am))end;return J end;local function ao(a0,ap,aq)local t,ar,as=a0:find('^%.%d+',ap+1)if as then aq=aq..as;a0=a0:sub(ar+1)else a0=a0:sub(ap+1)end;if a0:match'z$'then return aq,{h=0,m=0}end;a0=a0:gsub(':','')local t,t,F,E=a0:find('^([%+%-])(%d+)')if not F then return aq,nil end;if#E==2 then E=E..'00'end;local at={h=tonumber(E:sub(1,2)),m=tonumber(E:sub(3,4))}if F=='-'then at.h=-at.h;at.m=-at.m end;return aq,at end;function ab(ak,au)ak=ak:gsub('T',' ')local av=e.split(ak:lower())local W,a0=1,av[1]local function aw()W=W+1;a0=av[W]end;local n,ax,ay,aq,az;local at;local t,aA,aB,aC=a0:find'^(%d+)/(%d+)'if aB then if au then aB,aC=aC,aB end;t,t,n=a0:find('^/(%d+)',aA+1)aw()else n,aC,aB=a0:match('^(%d+)%-(%d+)%-(%d+)')if n then aw()end end;if a0 and not n and ai(a0)then if#a0<4 then aB=a0;aw()else n=true end end;if a0 and ag(a0)then a0=a0:sub(1,3)if not aa then ac()end;local af=aa[a0]if af then aC=af else error("not a month: "..a0)end;aw()end;if a0 and not n and ai(a0)then n=a0;aw()end;if a0 then t,aA,ay,ax=a0:find'^(%d+):(%d+)'local ap;if aA then t,ap,aq=a0:find('^:(%d+)',aA+1)aq,at=ao(a0,ap or aA,aq)else t,ap,ay,ax=a0:find'^(%d+)%.(%d+)'if ap then az=a0:match'[ap]m$'else local aD;t,aA,aD=a0:find('^(%d+)')if aA then ay=aD:sub(1,2)ax=aD:sub(3,4)aq=aD:sub(5,6)if#aq==0 then aq=nil end;aq,at=ao(a0,aA,aq)end end end end;local a6;if n==true then n=nil end;if not(n and aC and aB)then a6=i()end;aB=aB and aj(aB,1,31,'day')or(aC and 1 or a6:day())aC=aC and aj(aC,1,12,'month')or a6:month()n=n and tonumber(n)or a6:year()if n<100 then n=n+(n<35 and 2000 or 1900)end;ay=ay and aj(ay,0,az and 12 or 24,'hour')or 12;if az=='pm'then ay=ay+12 end;ax=ax and aj(ax,0,59)or 0;aq=aq and aj(aq,0,60)or 0;local K=i{year=n,month=aC,day=aB,hour=ay,min=ax,sec=aq}if at then local aE=false;if at.h~=0 then K:add{hour=-at.h}aE=true end;if at.m~=0 then K:add{min=-at.m}aE=true end;K.utc=true;if aE then K=K:toLocal()end end;return K end;function a1(ak)local aF,z=pcall(ab,ak)if not aF then z=z:gsub('.-:%d+: ','')return nil,z else return z end end;return i end end;do local _ENV=_ENV;package.preload["pl.List"]=function(...)local a=_G.arg;local aG,aH,aI,aJ=table.insert,table.remove,table.concat,table.sort;local setmetatable,getmetatable,type,tostring,string=setmetatable,getmetatable,type,tostring,string;local aK=require'pl.tablex'local aL,aM,aN,aO,aP,aQ=aK.filter,aK.imap,aK.imap2,aK.reduce,aK.transform,aK.removevalues;local aR=aK.sub;local f=require'pl.utils'local b=require'pl.class'local aS,aT,g,aU=f.array_tostring,f.split,f.assert_arg,f.function_arg;local aV=aK._normalize_slice;local aW=f.stdmt.MultiMap;local aX=f.stdmt.List;local aY;b(nil,nil,aX)local function aZ(j,a_)local b0=aX;if a_ then b0=getmetatable(a_)end;return setmetatable(j,b0)end;local function b1(j)return type(j)=='table'and not getmetatable(j)and#j>0 end;function aX._create(b2)if b1(b2)then return b2 end end;function aX:_init(b2)if self==b2 then return end;if b2 then for a4 in aY(b2)do aG(self,a4)end end end;aX.new=aX;function aX:clone()local b3=aZ({},self)b3:extend(self)return b3 end;function aX:append(W)aG(self,W)return self end;aX.push=aG;function aX:extend(b4)g(1,b4,'table')for W=1,#b4 do aG(self,b4[W])end;return self end;function aX:insert(W,b5)g(1,W,'number')aG(self,W,b5)return self end;function aX:put(b5)return self:insert(1,b5)end;function aX:remove(W)g(1,W,'number')aH(self,W)return self end;function aX:remove_value(b5)for W=1,#self do if self[W]==b5 then aH(self,W)return self end end;return self end;function aX:pop(W)if not W then W=#self end;g(1,W,'number')return aH(self,W)end;aX.get=aX.pop;local b6=aK.find;aX.index=b6;function aX:contains(b5)return b6(self,b5)and true or false end;function aX:count(b5)local _=0;for W=1,#self do if self[W]==b5 then _=_+1 end end;return _ end;function aX:sort(b7)if b7 then b7=aU(1,b7)end;aJ(self,b7)return self end;function aX:sorted(b7)return aX(self):sort(b7)end;function aX:reverse()local j=self;local J=#j;for W=1,J/2 do j[W],j[J]=j[J],j[W]J=J-1 end;return self end;function aX:minmax()local b8,b9=1e70,-1e70;for W=1,#self do local a4=self[W]if a4<b8 then b8=a4 end;if a4>b9 then b9=a4 end end;return b8,b9 end;function aX:slice(ba,bb)return aR(self,ba,bb)end;function aX:clear()for W=1,#self do aH(self)end;return self end;local bc=1.0e-10;function aX.range(bd,be,bf)if not be then be=bd;bd=1 end;if bf then g(3,bf,'number')if math.ceil(bf)~=bf then be=be+bc end else bf=1 end;g(1,bd,'number')g(2,be,'number')local j=aX()for W=bd,be,bf do aG(j,W)end;return j end;function aX:len()return#self end;function aX:chop(bg,bh)return aQ(self,bg,bh)end;function aX:splice(bi,bj)g(1,bi,'number')bi=bi-1;local W=1;for a4 in aY(bj)do aG(self,W+bi,a4)W=W+1 end;return self end;function aX:slice_assign(bg,bh,bk)g(1,bg,'number')g(1,bh,'number')bg,bh=aV(self,bg,bh)if bh>=bg then self:chop(bg,bh)end;self:splice(bg,bk)return self end;function aX:__concat(b4)g(1,b4,'table')local b3=self:clone()b3:extend(b4)return b3 end;function aX:__eq(b4)if#self~=#b4 then return false end;for W=1,#self do if self[W]~=b4[W]then return false end end;return true end;function aX:join(bl)bl=bl or''g(1,bl,'string')return aI(aS(self),bl)end;aX.concat=aI;local function bm(v)local ak=tostring(v)if type(v)=='string'then ak='"'..ak..'"'end;return ak end;function aX:__tostring()return'{'..self:join(',',bm)..'}'end;function aX:foreach(bn,...)bn=aU(1,bn)for W=1,#self do bn(self[W],...)end end;local function bo(a_,a5)local bp=a_[a5]if not bp then error(type(a_).." does not have method "..a5,3)end;return bp end;function aX:foreachm(a5,...)for W=1,#self do local a_=self[W]local bp=bo(a_,a5)bp(a_,...)end end;function aX:filter(bn,a)return aZ(aL(self,bn,a),self)end;function aX.split(ak,bl)g(1,ak,'string')return aZ(aT(ak,bl))end;function aX:map(bn,...)return aZ(aM(bn,self,...),self)end;function aX:transform(bn,...)aP(bn,self,...)return self end;function aX:map2(bn,b3,...)return aZ(aN(bn,self,b3,...),self)end;function aX:mapm(a5,...)local K={}for W=1,#self do local v=self[W]local bq=bo(v,a5)K[W]=bq(v,...)end;return aZ(K,self)end;local function br(bs,bp)return function(self,...)return self[bs](self,bp,...)end end;function aX.default_map_with(bt)return function(self,a5)local A;if bt then local bp=bo(bt,a5)A=br('map',bp)else A=br('mapn',a5)end;getmetatable(self)[a5]=A;return A end end;aX.default_map=aX.default_map_with;function aX:reduce(bn)return aO(bn,self)end;function aX:partition(bn,...)bn=aU(1,bn)local K={}for W=1,#self do local v=self[W]local b0=bn(v,...)if b0==nil then b0='<nil>'end;if not K[b0]then K[b0]=aX()end;K[b0]:append(v)end;return setmetatable(K,aW)end;function aX:iter()return aY(self)end;function aX.iterate(bk)if type(bk)=='string'then local bi=0;local J=#bk;local bu=string.sub;return function()bi=bi+1;if bi>J then return nil else return bu(bk,bi,bi)end end elseif type(bk)=='table'then local bi=0;local J=#bk;return function()bi=bi+1;if bi>J then return nil else return bk[bi]end end elseif type(bk)=='function'then return bk elseif type(bk)=='userdata'and io.type(bk)=='file'then return bk:lines()end end;aY=aX.iterate;return aX end end;do local _ENV=_ENV;package.preload["pl.Map"]=function(...)local a=_G.arg;local aK=require'pl.tablex'local f=require'pl.utils'local bv=f.stdmt;local bw=aK.deepcompare;local bx=require'pl.pretty'.write;local by=bv.Map;local bz=bv.Set;local b=require'pl.class'b(nil,nil,by)function by:_init(j)local bA=getmetatable(j)if bA==bz or bA==by then self:update(j)else return j end end;local function aZ(j)return setmetatable(j,require('pl.List'))end;by.keys=aK.keys;by.values=aK.values;function by:iter()return pairs(self)end;function by:items()local b3=aZ(aK.pairmap(function(bB,a4)return aZ{bB,a4}end,self))b3:sort(function(bC,bD)return bC[1]<bD[1]end)return b3 end;function by:setdefault(y,bE)local v=self[y]if v~=nil then return v end;self:set(y,bE)return bE end;by.len=aK.size;function by:set(y,v)self[y]=v end;function by:get(y)return rawget(self,y)end;local bF=aK.index_by;function by:getvalues(bG)return aZ(bF(self,bG))end;by.update=aK.update;function by:__eq(A)return bw(self,A,true)end;function by:__tostring()return bx(self,'')end;return by end end;do local _ENV=_ENV;package.preload["pl.MultiMap"]=function(...)local a=_G.arg;local f=require'pl.utils'local b=require'pl.class'local aX=require'pl.List'local by=require'pl.Map'local bH=f.stdmt.MultiMap;b(by,nil,bH)bH._name='MultiMap'function bH:_init(j)if not j then return end;self:update(j)end;function bH:update(j)f.assert_arg(1,j,'table')if by:class_of(j)then for bB,a4 in pairs(j)do self[bB]=aX()self[bB]:append(a4)end else for bB,a4 in pairs(j)do self[bB]=aX(a4)end end end;function bH:set(y,v)if v==nil then self[y]=nil else if not self[y]then self[y]=aX()end;self[y]:append(v)end end;return bH end end;do local _ENV=_ENV;package.preload["pl.OrderedMap"]=function(...)local a=_G.arg;local aK=require'pl.tablex'local f=require'pl.utils'local aX=require'pl.List'local bF,aJ,aI=aK.index_by,table.sort,table.concat;local b=require'pl.class'local by=require'pl.Map'local bI=b(by)bI._name='OrderedMap'local rawset=rawset;function bI:_init(j)rawset(self,'_keys',aX())if j then local bJ,bK=self:update(j)if not bJ then error(bK,2)end end end;local g,bL=f.assert_arg,f.raise;function bI:update(j)g(1,j,'table')if bI:class_of(j)then for bB,a4 in j:iter()do self:set(bB,a4)end elseif#j>0 then if type(j[1])=='table'then for t,bM in ipairs(j)do local y,bN=next(bM)if not y then return bL'empty pair initialization table'end;self:set(y,bN)end else return bL'cannot use an array to initialize an OrderedMap'end else for bB,a4 in pairs(j)do self:set(bB,a4)end end;return self end;function bI:set(y,v)if rawget(self,y)==nil and v~=nil then self._keys:append(y)rawset(self,y,v)else if v==nil then self._keys:remove_value(y)rawset(self,y,nil)else self[y]=v end end;return self end;bI.__newindex=bI.set;function bI:insert(bO,y,v)local bP=self[y]v=v or bP;if bP then self._keys:remove_value(y)end;if v then self._keys:insert(bO,y)rawset(self,y,v)end;return self end;function bI:keys()return self._keys end;function bI:values()return aX(bF(self,self._keys))end;function bI:sort(b7)aJ(self._keys,b7)return self end;function bI:iter()local W=0;local bG=self._keys;local bi;return function()W=W+1;if W>#bG then return nil end;bi=bG[W]return bi,self[bi]end end;bI.__pairs=bI.iter;function bI:__tostring()local K={}for W,a4 in ipairs(self._keys)do local v=self[a4]local bQ=tostring(v)if type(v)~='number'then bQ='"'..bQ..'"'end;K[W]=tostring(a4)..'='..bQ end;return'{'..aI(K,',')..'}'end;return bI end end;do local _ENV=_ENV;package.preload["pl.Set"]=function(...)local a=_G.arg;local aK=require'pl.tablex'local f=require'pl.utils'local aS,aI=f.array_tostring,table.concat;local bR,bS=aK.merge,aK.difference;local by=require'pl.Map'local b=require'pl.class'local bv=f.stdmt;local bz=bv.Set;b(by,nil,bz)bz.__index=nil;local function bT(j)return setmetatable(j,bz)end;function bz:_init(j)j=j or{}local bA=getmetatable(j)if bA==bz or bA==by then for bB in pairs(j)do self[bB]=true end else for t,a4 in ipairs(j)do self[a4]=true end end end;function bz:__tostring()return'['..aI(aS(bz.values(self)),',')..']'end;bz.values=by.keys;function bz.map(self,bq,...)bq=f.function_arg(1,bq)local K={}for bB in pairs(self)do K[bq(bB,...)]=true end;return bT(K)end;function bz.union(self,bU)return bR(self,bU,true)end;local function bV(self,B)local bA=getmetatable(B)if bA==bz or bA==by then return bz.union(self,B)else local bW=bz(self)bW[B]=true;return bW end end;bz.__add=bV;function bz.intersection(self,bU)return bR(self,bU,false)end;bz.__mul=bz.intersection;function bz.difference(self,bU)return bS(self,bU,false)end;local function bX(self,B)local bA=getmetatable(B)if bA==bz or bA==by then return bz.difference(self,B)else local bW=bz(self)bW[B]=nil;return bW end end;bz.__sub=bX;function bz.symmetric_difference(self,bU)return bS(self,bU,true)end;bz.__pow=bz.symmetric_difference;function bz.issubset(self,bU)for bB in pairs(self)do if not bU[bB]then return false end end;return true end;bz.__lt=bz.issubset;function bz.isempty(self)return next(self)==nil end;function bz.isdisjoint(bY,bZ)return bz.isempty(bz.intersection(bY,bZ))end;bz.len=aK.size;bz.__len=bz.len;function bz.__eq(bY,bZ)return bz.issubset(bY,bZ)and bz.issubset(bZ,bY)end;return bz end end;do local _ENV=_ENV;package.preload["pl.app"]=function(...)local a=_G.arg;local io,package,require=_G.io,_G.package,_G.require;local f=require'pl.utils'local b_=require'pl.path'local c0={}function c0.script_name()if _G.arg and _G.arg[0]then return _G.arg[0]end;return f.raise("No script name found")end;function c0.require_here(c1)local a0=b_.dirname(c0.script_name())if not b_.isabs(a0)then a0=b_.join(b_.currentdir(),a0)end;if a0:sub(-1,-1)~=b_.sep then a0=a0 ..b_.sep end;if c1 then if b_.is_windows then c1=c1:gsub('/','\\')end;if b_.isabs(c1)then a0=c1 ..b_.sep else a0=a0 ..c1 ..b_.sep end end;local c2=b_.is_windows and'dll'or'so'local c3=package.path:find'^;'and''or';'local c4=package.cpath:find'^;'and''or';'package.path=('%s?.lua;%s?%sinit.lua%s%s'):format(a0,a0,b_.sep,c3,package.path)package.cpath=('%s?.%s%s%s'):format(a0,c2,c4,package.cpath)return a0 end;function c0.appfile(c5)local c6,bK=c0.script_name()if not c6 then return f.raise(bK)end;local c7=b_.basename(c6)local a5=b_.splitext(c7)local c8=b_.join(b_.expanduser('~'),'.'..a5)if not b_.isdir(c8)then local c9=b_.mkdir(c8)if not c9 then return f.raise('cannot create '..c8)end end;return b_.join(c8,c5)end;function c0.platform()if b_.is_windows then return'Windows'else local bp=io.popen('uname')local K=bp:read()if K=='Darwin'then K='OSX'end;bp:close()return K end end;function c0.lua()local ca=_G.arg;if not ca then return f.raise"not in a main program"end;local cb={}local W=-1;while true do table.insert(cb,1,ca[W])if not ca[W-1]then return f.quote_arg(cb),ca[W]end;W=W-1 end end;function c0.parse_args(ca,cc,cd)if not ca then ca=_G.arg;if not ca then f.raise"Not in a main program: 'arg' not found"end end;local ce={}for bB,a4 in pairs(cc or{})do if type(bB)=="number"then bB=a4 end;ce[bB]=true end;local cf;if not cd then cf=setmetatable({},{__index=function(t,y)return y end})else cf={}for bB,cg in pairs(cd)do if type(bB)=="number"then bB=cg end;if type(cg)=="string"then cg={cg}end;if type(cg)=="table"then for W,ch in ipairs(cg)do cf[ch]=bB end end;cf[bB]=bB end;do local ci={}for bB,a4 in pairs(ce)do if not cf[bB]then cf[bB]=bB;ci[bB]=true else ci[cf[bB]]=true end end;ce=ci end end;for bB,cj in pairs(cf)do if ce[cj]then ce[bB]=true end end;local ck={}local cl={}local W=1;while W<=#ca do local cm=ca[W]local a4=cm:match('^-(.+)')local cn;if not a4 then ck[#ck+1]=cm else if a4:find'^-'then cn=true;a4=a4:sub(2)end;if ce[a4]then if W==#ca or ca[W+1]:find'^-'then return f.raise("no value for '"..a4 .."'")end;cl[cf[a4]]=ca[W+1]W=W+1 else local co,v=f.splitv(a4,'[=:]',false,2)co=co or a4;v=v or true;if not cn then if#co>1 then if co:find'.%d+'then v=co:sub(2)co=co:sub(1,1)else for W=1,#co do local bp=co:sub(W,W)if not cf[bp]then return f.raise("unknown flag '"..bp.."'")else bp=cf[bp]end;cl[bp]=true end;v=nil end else v=v or true end end;if v then if not cf[co]then return f.raise("unknown flag '"..co.."'")else co=cf[co]end;cl[co]=v end end end;W=W+1 end;return cl,ck end;return c0 end end;do local _ENV=_ENV;package.preload["pl.array2d"]=function(...)local a=_G.arg;local tonumber,tostring,io,ipairs,string,table=_G.tonumber,_G.tostring,_G.io,_G.ipairs,_G.string,_G.table;local setmetatable,getmetatable=setmetatable,getmetatable;local aK=require'pl.tablex'local f=require'pl.utils'local cp=require'pl.types'local aM,cq,aO,bG,cr,cs,bF=aK.imap,aK.map,aK.reduce,aK.keys,aK.map2,aK.set,aK.index_by;local ct=table.remove;local cu,cv,g=f.splitv,f.fprintf,f.assert_arg;local cw=string.byte;local cx=io.stdout;local ax=math.min;local cy={}local function a_(cz,cA)local bA=getmetatable(cz)if bA then setmetatable(cA,bA)end;return cA end;local function aZ(K)return setmetatable(K,require('pl.List'))end;function cy.size(cm)g(1,cm,'table')return#cm,#cm[1]end;do local function cB(j,bB)return j[bB]end;function cy.column(cm,cC)g(1,cm,'table')return aZ(aM(cB,cm,cC))end end;local cD=cy.column;function cy.row(cm,W)g(1,cm,'table')local cE=cm[W]local cF={}for J,a4 in ipairs(cE)do cF[J]=a4 end;return aZ(cF)end;function cy.map(bp,cm,a)g(2,cm,'table')bp=f.function_arg(1,bp)return a_(cm,aM(function(cE)return aM(bp,cE,a)end,cm))end;function cy.reduce_rows(bp,cm)g(1,cm,'table')return cq(function(cE)return aO(bp,cE)end,cm)end;function cy.reduce_cols(bp,cm)g(1,cm,'table')return cq(function(u)return aO(bp,cD(cm,u))end,bG(cm[1]))end;function cy.reduce2(cG,cH,cm)g(3,cm,'table')local cI=cy.reduce_rows(cH,cm)return aO(cG,cI)end;function cy.map2(bp,cJ,cK,cm,cL,a)g(1,cm,'table')g(2,cL,'table')bp=f.function_arg(1,bp)if cJ==1 and cK==2 then return aM(function(cE)return cr(bp,cm,cE,a)end,cL)elseif cJ==2 and cK==1 then return aM(function(cE)return cr(bp,cE,cL,a)end,cm)elseif cJ==1 and cK==1 then return cr(bp,cm,cL)elseif cJ==2 and cK==2 then return cr(function(cM,cN)return cr(bp,cM,cN,a)end,cm,cL)end end;function cy.product(bp,bC,bD)bp=f.function_arg(1,bp)g(2,bC,'table')g(3,bD,'table')local K={}for W,a4 in ipairs(bD)do K[W]=cq(bp,bC,a4)end;return K end;function cy.flatten(j)local K={}local bB=1;local cO,cP=cy.size(j)for cF=1,cO do local cE=j[cF]for u=1,cP do K[bB]=cE[u]bB=bB+1 end end;return aZ(K)end;function cy.reshape(j,cQ,cR)local cS,cT=cy.size(j)local cU=cS*cT/cQ;local K={}local cV,cW=1,1;for W=1,cQ do local cE={}for cC=1,cU do cE[cC]=j[cV][cW]if not cR then cW=cW+1;if cW>cT then cV=cV+1;cW=1 end else cV=cV+1;if cV>cS then cW=cW+1;cV=1 end end end;K[W]=cE end;return a_(j,K)end;function cy.transpose(j)g(1,j,'table')local t,u=cy.size(j)return cy.reshape(j,u,true)end;function cy.swap_rows(j,bg,bh)g(1,j,'table')j[bg],j[bh]=j[bh],j[bg]return j end;function cy.swap_cols(j,cX,cY)g(1,j,'table')for t,cE in ipairs(j)do cE[cX],cE[cY]=cE[cY],cE[cX]end;return j end;function cy.extract_rows(j,cZ)return a_(j,bF(j,cZ))end;function cy.extract_cols(j,c_)g(1,j,'table')local K={}for W=1,#j do K[W]=bF(j[W],c_)end;return a_(j,K)end;cy.remove_row=ct;function cy.remove_col(j,cC)g(1,j,'table')for W=1,#j do ct(j[W],cC)end end;do local function d0(ak)local cF,u=ak:match'R(%d+)C(%d+)'if cF then cF,u=tonumber(cF),tonumber(u)return cF,u end;u,cF=ak:match'(%a+)(%d+)'if u then local d1=0;for W=1,#u do d1=d1*26+cw(u:sub(W,W))-cw'A'+1 end;return tonumber(cF),d1 end;error('bad cell specifier: '..ak)end;function cy.parse_range(ak)g(1,ak,'string')ak=ak:upper()if ak:find':'then local bd,be=cu(ak,':')local bg,cX=d0(bd)local bh,cY=d0(be)return bg,cX,bh,cY else local W,cC=d0(ak)return W,cC end end end;function cy.range(j,d2)g(1,j,'table')return cy.slice(j,cy.parse_range(d2))end;local d3;do local function d4(a4,d5)if not a4 then return a4 end;if a4<0 then a4=d5+a4+1 end;if a4<1 then a4=1 end;if a4>d5 then a4=d5 end;return a4 end;function cy.default_range(j,bg,cX,bh,cY)local cS,cT=cy.size(j)bg=d4(bg or 1,cS)cX=d4(cX or 1,cT)bh=d4(bh or cS,cS)cY=d4(cY or cT,cT)return bg,cX,bh,cY end;d3=cy.default_range end;function cy.slice(j,bg,cX,bh,cY)g(1,j,'table')bg,cX,bh,cY=d3(j,bg,cX,bh,cY)local K={}for W=bg,bh do local v;local cE=j[W]if cX==cY then v=cE[cX]else v={}for cC=cX,cY do v[#v+1]=cE[cC]end end;K[#K+1]=v end;if bg==bh then K=K[1]end;return a_(j,K)end;function cy.set(j,bN,bg,cX,bh,cY)bg,cX,bh,cY=d3(j,bg,cX,bh,cY)local W=bg;if cp.is_callable(bN)then local d6=bN;bN=function(cC)return d6(W,cC)end end;while W<=bh do cs(j[W],bN,cX,cY)W=W+1 end end;function cy.write(j,bp,D,bg,cX,bh,cY)g(1,j,'table')bp=bp or cx;local d7;if D then d7=function(cE,cC)cv(bp,D,cE[cC])end else d7=function(cE,cC)bp:write(tostring(cE[cC]),' ')end end;local function d8()bp:write'\n'end;cy.forall(j,d7,d8,bg,cX,bh,cY)end;function cy.forall(j,d9,da,bg,cX,bh,cY)g(1,j,'table')bg,cX,bh,cY=d3(j,bg,cX,bh,cY)for W=bg,bh do local cE=j[W]for cC=cX,cY do d9(cE,cC)end;if da then da(W)end end end;function cy.move(db,dc,dd,b2,bg,cX,bh,cY)g(1,db,'table')g(4,b2,'table')bg,cX,bh,cY=d3(b2,bg,cX,bh,cY)local cS,cT=cy.size(db)bh,cY=ax(cS,bh),ax(cT,cY)dd=dd-1;for W=bg,bh do local de,df=db[W+dc-1],b2[W]for cC=cX,cY do de[cC+dd]=df[cC]end end end;function cy.iter(cm,dg,bg,cX,bh,cY)g(1,cm,'table')bg,cX,bh,cY=d3(cm,bg,cX,bh,cY)local W,cC=bg,cX-1;local cE=cm[W]return function()cC=cC+1;if cC>cY then cC=cX;W=W+1;cE=cm[W]if W>bh then return nil end end;if dg then return W,cC,cE[cC]else return cE[cC]end end end;function cy.columns(cm)g(1,cm,'table')local J=#cm[1]local W=0;return function()W=W+1;if W>J then return nil end;return cD(cm,W),W end end;function cy.rows(cm)g(1,cm,'table')local J=#cm;local W=0;return function()W=W+1;if W>J then return nil end;return cy.row(cm,W),W end end;function cy.new(cO,cP,v)local K={}local bn=cp.is_callable(v)for W=1,cO do local cE={}if bn then for cC=1,cP do cE[cC]=v(W,cC)end else for cC=1,cP do cE[cC]=v end end;K[W]=cE end;return K end;return cy end end;do local _ENV=_ENV;package.preload["pl.class"]=function(...)local a=_G.arg;local error,getmetatable,io,pairs,rawget,rawset,setmetatable,tostring,type=_G.error,_G.getmetatable,_G.io,_G.pairs,_G.rawget,_G.rawset,_G.setmetatable,_G.tostring,_G.type;local dh;local function di(u,a_,...)local dj=rawget(u,'_init')local dk=rawget(u,'_parent_with_init')if dk then if not dj then dj=rawget(dk,'_init')dk=rawget(dk,'_parent_with_init')end;if dk then rawset(a_,'super',function(a_,...)di(dk,a_,...)end)end else rawset(a_,'super',nil)end;local K=dj(a_,...)if dk then rawset(a_,'super',nil)end;return K end;local function dl(self,b0)if b0==nil then return getmetatable(self)end;local A=getmetatable(self)if not A then return false end;while A do if A==b0 then return true end;A=rawget(A,'_base')end;return false end;local function dm(b0,a_)if type(b0)~='table'or not rawget(b0,'is_a')then return false end;return b0.is_a(a_,b0)end;local function dn(b0,a_)return setmetatable(a_,b0)end;local function dp(a_)local bA=a_._class;local a5=rawget(bA,'_name')setmetatable(a_,nil)local a2=tostring(a_)setmetatable(a_,bA)if a5 then a2=a5 ..a2:gsub('table','')end;return a2 end;local function dq(dr,p,ds)for bB,a4 in pairs(p)do if not ds or dr[bB]==nil then dr[bB]=a4 end end end;local function dt(c1,du,u)local bA={}local dv=type(c1)=='table'and not getmetatable(c1)if dv then u=c1;c1=u._base else u=u or{}end;if type(c1)=='table'then dq(u,c1,dv)u._base=c1;if rawget(u,'_handler')then bA.__index=u._handler end elseif c1~=nil then error("must derive from a table type",3)end;u.__index=u;setmetatable(u,bA)if not dv then if c1 and rawget(c1,'_init')then u._parent_with_init=c1 end;u._init=nil end;if c1 and rawget(c1,'_class_init')then c1._class_init(u,du)end;bA.__call=function(dw,...)local a_;if rawget(u,'_create')then a_=u._create(...)end;if not a_ then a_={}end;setmetatable(a_,u)if rawget(u,'_init')or rawget(u,'_parent_with_init')then local K=di(u,a_,...)if K then a_=K;setmetatable(a_,u)end end;if c1 and rawget(c1,'_post_init')then c1._post_init(a_)end;return a_ end;u.catch=function(self,dx)if type(self)=="function"then dx=self end;u._handler=dx;bA.__index=dx end;u.is_a=dl;u.class_of=dm;u.cast=dn;u._class=u;if not rawget(u,'__tostring')then u.__tostring=dp end;return u end;local b;b=setmetatable({},{__call=function(bn,...)return dt(...)end,__index=function(dy,y)if y=='class'then io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')return b end;dh=dh or require'pl.compat'local dz=dh.getfenv(2)return function(...)local u=dt(...)u._name=y;rawset(dz,y,u)return u end end})b.properties=b()function b.properties._class_init(b0)b0.__index=function(j,y)local a4=b0[y]if a4 then return a4 end;a4=rawget(b0,'get_'..y)if a4 then return a4(j)end;return rawget(j,'_'..y)end;b0.__newindex=function(j,y,bN)local a0='set_'..y;local dA=b0[a0]if dA then dA(j,bN)else rawset(j,y,bN)end end end;return b end end;do local _ENV=_ENV;package.preload["pl.compat"]=function(...)local a=_G.arg;local dh={}dh.lua51=_VERSION=='Lua 5.1'dh.jit=tostring(assert):match('builtin')~=nil;if dh.jit then dh.jit52=not loadstring("local goto = 1")end;dh.dir_separator=_G.package.config:sub(1,1)dh.is_windows=dh.dir_separator=='\\'function dh.execute(cb)local dB,dC,dD=os.execute(cb)if dC=="No error"and dD==0 and dh.is_windows then dD=-1 end;if dh.lua51 and not dh.jit52 then if dh.is_windows then return dB==0,dB else dB=dB>255 and dB/256 or dB;return dB==0,dB end else if dh.is_windows then return dD==0,dD else return not not dB,dD end end end;if dh.lua51 then if not dh.jit then local dE=load;function dh.load(a2,b2,dF,dz)local dG,bK;if type(a2)=='string'then if a2:byte(1)==27 and not(dF or'bt'):find'b'then return nil,"attempt to load a binary chunk"end;dG,bK=loadstring(a2,b2)else dG,bK=dE(a2,b2)end;if dG and dz then setfenv(dG,dz)end;return dG,bK end else dh.load=load end;dh.setfenv,dh.getfenv=setfenv,getfenv else dh.load=load;function dh.setfenv(bp,j)bp=type(bp)=='function'and bp or debug.getinfo(bp+1,'f').func;local a5;local dH=0;repeat dH=dH+1;a5=debug.getupvalue(bp,dH)until a5=='_ENV'or a5==nil;if a5 then debug.upvaluejoin(bp,dH,function()return a5 end,1)debug.setupvalue(bp,dH,j)end;if bp~=0 then return bp end end;function dh.getfenv(bp)local bp=bp or 0;bp=type(bp)=='function'and bp or debug.getinfo(bp+1,'f').func;local a5,v;local dH=0;repeat dH=dH+1;a5,v=debug.getupvalue(bp,dH)until a5=='_ENV'or a5==nil;return v end end;if not table.pack then function table.pack(...)return{n=select('#',...),...}end end;if not table.unpack then table.unpack=unpack end;if not package.searchpath then function package.searchpath(a5,b_,dI,dJ)if type(a5)~="string"then error(("bad argument #1 to 'searchpath' (string expected, got %s)"):format(type(b_)),2)end;if type(b_)~="string"then error(("bad argument #2 to 'searchpath' (string expected, got %s)"):format(type(b_)),2)end;if dI~=nil and type(dI)~="string"then error(("bad argument #3 to 'searchpath' (string expected, got %s)"):format(type(b_)),2)end;if dJ~=nil and type(dJ)~="string"then error(("bad argument #4 to 'searchpath' (string expected, got %s)"):format(type(b_)),2)end;dI=dI or"."dJ=dJ or dh.dir_separator;do local ak,dK=a5:find(dI,nil,true)while ak do a5=a5:sub(1,ak-1)..dJ..a5:sub(dK+1,-1)ak,dK=a5:find(dI,ak+#dJ+1,true)end end;local dL={}for A in b_:gmatch('[^;]+')do local dM=A:gsub('?',a5)dL[#dL+1]=dM;local bp=io.open(dM,'r')if bp then bp:close()return dM end end;return nil,"\tno file '"..table.concat(dL,"'\n\tno file '").."'"end end;if not warn then local dN=false;function warn(dO,...)if type(dO)=="string"and dO:sub(1,1)=="@"then if dO=="@on"then dN=true;return end;if dO=="@off"then dN=false;return end;return end;if dN then io.stderr:write("Lua warning: ",dO,...)io.stderr:write("\n")end end end;return dh end end;do local _ENV=_ENV;package.preload["pl.comprehension"]=function(...)local a=_G.arg;local f=require'pl.utils'local dP,dQ=pcall(require,"pl.luabalanced")if not dP then dQ=require'luabalanced'end;local dR=math.max;local dS=table.concat;local dT={list={init=' {} ',accum=' __result[#__result+1] = (%s) '},table={init=' {} ',accum=' local __k, __v = %s __result[__k] = __v '},sum={init=' 0 ',accum=' __result = __result + (%s) '},min={init=' nil ',accum=' local __tmp = %s '..' if __result then if __tmp < __result then '..'__result = __tmp end else __result = __tmp end '},max={init=' nil ',accum=' local __tmp = %s '..' if __result then if __tmp > __result then '..'__result = __tmp end else __result = __tmp end '}}local function dU(dV)local bO=1;local dW;local dX,dY=dV:match('^%s*([%a_][%w_]*)%s*%(()',bO)local dZ=#dV+1;if dX then local d_,e0=dQ.match_bracketed(dV,dY-1)assert(d_,'syntax error')if dV:match('^%s*$',e0)then dW=dX;dZ=e0-1;bO=dY end end;dW=dW or"list"local cA;cA,bO=dQ.match_explist(dV,bO)assert(cA,"syntax error: missing expression list")cA=dS(cA,', ')local e1={}local e2={}local e3={}while 1 do local dY=dV:match('^%s*for%s+()',bO)if not dY then break end;bO=dY;local e4;e4,bO=dQ.match_namelist(dV,bO)assert(#e4>0,'syntax error: zero variables')for t,e5 in ipairs(e4)do assert(not e5:match'^__',"identifier "..e5 .." may not contain __ prefix")end;e2[#e2+1]=e4;local e6,dY=dV:match('^(=)%s*()',bO)if not e6 then e6,dY=dV:match('^(in)%s+()',bO)end;if e6 then bO=dY;local e7;e7,bO=dQ.match_explist(dV,bO)assert(#e7>0,'syntax error: zero expressions')assert(e6~='='or#e7==2 or#e7==3,'syntax error: numeric for requires 2 or three expressions')e1[#e2]=e6;e3[#e2]=e7 else e1[#e2]=false;e3[#e2]=false end end;assert(#e2>0,'syntax error: missing "for" clause')local e8={}while 1 do local dY=dV:match('^%s*if%s+()',bO)if not dY then break end;bO=dY;local e9;e9,bO=dQ.match_expression(dV,bO)assert(e9,'syntax error: predicated expression not found')e8[#e8+1]=e9 end;local ea=''dQ.gsub(dV,function(eb,ec)if eb=='e'then ea=ea..' '..ec..' 'end end)local ed=0;ea:gsub('[%a_][%w_]*',function(ak)local ak=ak:match('^_(%d+)$')if ak then ed=dR(ed,tonumber(ak))end end)if bO~=dZ then assert(false,"syntax error: unrecognized "..dV:sub(bO))end;return cA,e1,e2,e3,e8,dW,ed end;local function ee(cA,e1,e2,e3,e8,dW,ed)local ef=assert(dT[dW])local eg=ef.accum:gsub('%%s',cA)for W=#e8,1,-1 do local e9=e8[W]eg=' if '..e9 ..' then '..eg..' end 'end;for W=#e2,1,-1 do if not e1[W]then local eh='__in'..W;local bi='__idx'..W;eg=' for '..bi..' = 1, #'..eh..' do '..' local '..e2[W][1]..' = '..eh..'['..bi..'] '..eg..' end 'else eg=' for '..dS(e2[W],', ')..' '..e1[W]..' '..dS(e3[W],', ')..' do '..eg..' end 'end end;eg=' local __result = ( '..ef.init..' ) '..eg;return eg end;local function ei(eg,ej,ed,e3,dz)assert(ej>0)local p={}for W=1,ed do p[#p+1]='_'..W end;for W=1,ej do if not e3[W]then local a5='__in'..W;p[#p+1]=a5 end end;if#p>0 then eg=' local '..dS(p,', ')..' = ... '..eg end;eg=eg..' return __result 'local bp,bK=f.load(eg,'tmp','t',dz)if not bp then assert(false,bK..' with generated code '..eg)end;return bp end;local function ek(dV,dz)local cA,e1,e2,e3,e8,dW,ed=dU(dV)local eg=ee(cA,e1,e2,e3,e8,dW,ed)local bp=ei(eg,#e2,ed,e3,dz)return bp end;local function bW(dz)if not dz then dz=f.getfenv(2)end;local bA={}local el=setmetatable({},bA)function bA:__index(dV)local bp=ek(dV,dz)self[dV]=bp;return bp end;bA.__call=bA.__index;el.new=bW;return el end;local em={}em.new=bW;return em end end;do local _ENV=_ENV;package.preload["pl.config"]=function(...)local a=_G.arg;local type,tonumber,ipairs,io,table=_G.type,_G.tonumber,_G.ipairs,_G.io,_G.table;local function aT(ak,en)local K={}local eo=table.insert;en='[^'..en..']+'for bB in ak:gmatch(en)do eo(K,bB)end;return K end;local function ep(ak)return ak:gsub('^%s+',''):gsub('%s+$','')end;local function eq(ak)return ak:gsub("['\"](.*)['\"]",'%1')end;local er={}function er.lines(c5)local bp,es,bK;local et=''if type(c5)=='string'then bp,bK=io.open(c5,'r')if not bp then return nil,bK end;es=true else bp=c5 or io.stdin;if not c5.read then return nil,'not a file-like object'end end;if not bp then return nil,'file is nil'end;return function()local eu=bp:read()while eu do if eu:match'%S'and not eu:match'^%s*[;#]'then local W=eu:find'\\%s*$'if W then et=et..eu:sub(1,W-1)elseif et==''then return eu else eu=et..eu;et=''return eu end end;eu=bp:read()end;if es then bp:close()end end end;function er.read(c5,ev)local ew;local aY,bK=er.lines(c5)if not aY then return nil,bK end;local et=aY()ev=ev or{}if ev.smart then ew=true;if et:match'^[^=]+='then ev.keysep='='elseif et:match'^[^:]+:'then ev.keysep=':'ev.list_delim=':'elseif et:match'^%S+%s+'then ev.keysep=' 'if et:match'^%S+%s+%S+%s+%S+'then ev.list_delim=' 'end;ev.variabilize=false end end;local function ex(co,ey)local v=ev[co]if v==nil then return ey else return v end end;local ez='^[%d%+%-]'local j={}local eA=j;local eB=ex('variabilize',true)local eC=ex('list_delim',',')local eD=ex('convert_numbers',true)local eE=ex('convert_boolean',false)local eF=ex('trim_space',true)local eG=ex('trim_quotes',false)local eH=ex('ignore_assign',false)local eI=ex('keysep','=')local eJ=eI==' 'and'%s+'or'%s*'..eI..'%s*'if eC==' 'then eC='%s+'end;local function eK(y)if eB then y=y:gsub('[^%w]','_')end;return y end;local function eL(bN)if eC and bN:find(eC)then bN=aT(bN,eC)for W,a4 in ipairs(bN)do bN[W]=eL(a4)end elseif eD and bN:find(ez)then local v=tonumber(bN)if not v and bN:match' kB$'then bN=bN:gsub(' kB','')v=tonumber(bN)end;if v then bN=v end elseif eE and bN=='true'then return true elseif eE and bN=='false'then return false end;if type(bN)=='string'then if eF then bN=ep(bN)end;if not eG and ew and bN:match'^"'then eG=true end;if eG then bN=eq(bN)end end;return bN end;while et do if et:find('^%[')then local eM=eK(et:match('%[([^%]]+)%]'))j=eA;j[eM]={}j=j[eM]else et=et:gsub('^%s*','')local bg,bh=et:find(eJ)if bg and not eH then local y=eK(et:sub(1,bg-1))local bN=eL(et:sub(bh+1))j[y]=bN else j[#j+1]=eL(et)end end;et=aY()end;return eA end;return er end end;do local _ENV=_ENV;package.preload["pl.data"]=function(...)local a=_G.arg;local f=require'pl.utils'local eN=rawget(_G,'_DEBUG')local eO,aU,eP,aS=f.patterns,f.function_arg,f.split,f.array_tostring;local N,aI=table.insert,table.concat;local eQ=string.gsub;local io=io;local _G,print,type,tonumber,ipairs,setmetatable=_G,print,type,tonumber,ipairs,setmetatable;local eR={}local eS;local function eT(ak)return ak:gsub('%s+$','')end;local function ep(ak)return eT(ak):gsub('^%s*','')end;local function aZ(eu)return setmetatable(eu,require('pl.List'))end;local function bJ(bn,j)local K={}for W=1,#j do K[W]=bn(j[W])end;return K end;local function aT(et,bl,eU,J)local eV;if eU and et:match'"'then et=et:gsub('"([^"]+)"',function(a2)local ak,_=a2:gsub(',','\001')if _>0 then eV=true end;return ak end)if eV then eV=function(ak)return ak:gsub('\001',',')end end end;local K=eP(et,bl,false,J)if eU then if eV then K=bJ(eV,K)end;if et:match',$'then N(K,'')end end;return aZ(K)end;local function eW(j,a4)for W=1,#j do if a4==j[W]then return W end end end;local eX={column_by_name=function(self,a5)if type(a5)=='number'then a5='$'..a5 end;local eY={}for K in eR.query(self,a5)do N(eY,K)end;return aZ(eY)end,copy_select=function(self,eZ)eZ=eS(eZ,self)local aY=eR.query(self,eZ)local K={}local cE=aZ{aY()}while#cE>0 do N(K,cE)cE=aZ{aY()}end;K.delim=self.delim;return eR.new(K,aT(eZ.fields,','))end,column_names=function(self)return self.fieldnames end}local cy;eX.__index=function(self,a5)local bp=eX[a5]if bp then return bp end;if not cy then cy=require'pl.array2d'end;return cy[a5]end;local e_={',','\t',' ',';'}local function f0(et)if et==''then return' 'end;for t,bl in ipairs(e_)do if et:find(bl)then return bl==' 'and'%s+'or bl end end;return' 'end;local function f1(bp,dF)local f2,bK;local f3=dF=='r'if type(bp)=='string'then if bp=='stdin'then bp=io.stdin elseif bp=='stdout'then bp=io.stdout else bp,bK=io.open(bp,dF)if not bp then return nil,bK end;f2=true end end;if bp and(f3 and not bp.read or not f3 and not bp.write)then return nil,"not a file-like object"end;return bp,nil,f2 end;function eR.read(c5,ev)local f4,et;local O={}if not ev then ev={}end;local bp,bK,f2=f1(c5,'r')if not bp then return nil,bK end;local f5=ev.thousands_dot;local eU=ev.csv;if eU then ev.delim=','end;local tonumber=tonumber;local function f6(b5)if f5 then b5=b5:gsub('%.(...)','%1')end;if eU and b5==''then b5='0'end;local a4=tonumber(b5)if a4==nil then return nil,"not a number"end;return a4 end;f4=1;et=bp:read()if not et then return nil,"empty file"end;O.delim=ev.delim and ev.delim or f0(et)local bl=O.delim;local f7;local f8={}local function f9(bi,fa)f7=f7 or{}N(f8,bi)N(f7,fa)end;if ev.numfields then for t,J in ipairs(ev.numfields)do f9(J,f6)end end;local fb;if bl=='%s+'and et:find(bl)==1 then fb=function(ak)return ak:gsub('^%s+','')end;et=fb(et)end;if not ev.fieldnames then local fc,fd;fc=aT(et,bl,eU)if not ev.convert then fd=bJ(tonumber,fc)if#fd==#fc then N(O,fd)for W=1,#fd do f9(W,f6)end else fd=nil end else for bi,fa in pairs(ev.convert)do f9(bi,fa)end end;if fd==nil then ev.fieldnames=fc end;et=bp:read()f4=f4+1;if fb then et=fb(et)end elseif type(ev.fieldnames)=='string'then ev.fieldnames=aT(ev.fieldnames,bl,eU)end;local fe;if ev.fieldnames then O.fieldnames=ev.fieldnames;if ev.last_field_collect then fe=#O.fieldnames end;if not ev.no_convert then local fc=aT(et,O.delim,eU,fe)for W=1,#fc do if not eW(f8,W)and f6(fc[W])then f9(W,f6)end end end end;while et do if not et:find('^%s*$')then if fb then et=fb(et)end;local fc=aT(et,bl,eU,fe)if f7 then for bB=1,#f8 do local W,fa=f8[bB],f7[bB]local v,bK=fa(fc[W])if v==nil then return nil,bK..": "..fc[W].." at line "..f4 else fc[W]=v end end end;N(O,fc)end;et=bp:read()f4=f4+1 end;if f2 then bp:close()end;if bl=='%s+'then O.delim=' 'end;if not O.fieldnames then O.fieldnames={}end;return eR.new(O)end;local function ff(eR,bp,cE,bl)eR.temp=aS(cE,eR.temp)bp:write(aI(eR.temp,bl),'\n')end;function eX:write_row(bp,cE)ff(self,bp,cE,self.delim)end;function eR.write(eR,c5,fg,bl)local bp,bK,f2=f1(c5,'w')if not bp then return nil,bK end;if not fg then fg=eR.fieldnames end;bl=bl or'\t'if fg and#fg>0 then bp:write(aI(fg,bl),'\n')end;for W=1,#eR do ff(eR,bp,eR[W],bl)end;if f2 then bp:close()end;return true end;function eX:write(c5)eR.write(self,c5,self.fieldnames,self.delim)end;local function fh(fc,fi)for W=1,#fc do local bp=ep(fc[W])fi[W]=bp;fc[W]=bp:gsub('%W','_')end end;function eR.new(z,fg)z.fieldnames=z.fieldnames or fg or''if not z.delim and type(z.fieldnames)=='string'then z.delim=f0(z.fieldnames)z.fieldnames=aT(z.fieldnames,z.delim)end;z.fieldnames=aZ(z.fieldnames)z.original_fieldnames={}fh(z.fieldnames,z.original_fieldnames)setmetatable(z,eX)return z end;local fj=[[
return function (t)
    local i = 0
    local v
    local ls = {}
    for i,v in ipairs(t) do
        if CONDITION then
            ls[#ls+1] = v
        end
    end
    table.sort(ls,function(v1,v2)
        return SORT_EXPR
    end)
    local n = #ls
    return function()
        i = i + 1
        v = ls[i]
        if i > n then return end
        return FIELDLIST
    end
end
]]local fk=[[
return function (t)
    local n = #t
    local i = 0
    local v
    return function()
        repeat
            i = i + 1
            v = t[i]
        until i > n or CONDITION
        if i > n then return end
        return FIELDLIST
    end
end
]]local function fl(ak)return type(ak)=='string'end;local fm;local function fn(eR)return aI(eR.fieldnames,',')end;local function fo(eR,bp)local bi;if bp:find'^%d+$'then bi=tonumber(bp)else bi=eW(eR.fieldnames,bp)end;if bi then return'v['..bi..']'else fm=bp..' not found in '..fn(eR)return bp end end;local function fp(eR,fq)fm=nil;local fc=fq.fields;local f8=fc:find'%$'or#eR.fieldnames==0;if fc:find'^%s*%*%s*'then if not f8 then fc=fn(eR)else local fr=#eR[1]fc={}for W=1,fr do N(fc,'$'..W)end;fc=aI(fc,',')end end;local fs=eO.IDEN;if f8 then fs='%$(%d+)'else fc=eT(fc):gsub('[^,%w]','_')end;local fo=f.bind1(fo,eR)local c9=eQ(fc,fs,fo)if fm then return nil,fm end;fq.fields=fc;fq.proc_fields=c9;fq.where=fq.where or'true'if fl(fq.where)then fq.where=eQ(fq.where,fs,fo)fm=nil end;return true end;eS=function(ak,eR)local ft;local fq={}local fu,fv=ak:find('where ')local bY,bZ=ak:find('sort by ')if fu then ft=(bY or 0)-1;fq.where=ak:sub(fv+1,ft)end;if bY then fq.sort_by=ak:sub(bZ+1)end;ft=(fu or bY or 0)-1;fq.fields=ak:sub(1,ft)local dP,bK=fp(eR,fq)if not dP then return nil,bK else return fq end end;function eR.query(eR,eZ,fw,fx)local bK;if fl(eZ)then eZ,bK=eS(eZ,eR)if not eZ then return nil,bK end elseif type(eZ)=='table'then if type(eZ.fields)=='table'then eZ.fields=aI(eZ.fields,',')end;if not eZ.proc_fields then local dP,bK=fp(eR,eZ)if not dP then return nil,bK end end else return nil,"condition must be a string or a table"end;local fy;if eZ.sort_by then fy=fj else fy=fk end;local fc=eZ.proc_fields or eZ.fields;if fx then fc='{'..fc..'}'end;fy=fy:gsub('FIELDLIST',fc)if fl(eZ.where)then fy=fy:gsub('CONDITION',eZ.where)eZ.where=nil else fy=fy:gsub('CONDITION','_condn(v)')eZ.where=aU(0,eZ.where,'condition.where must be callable')end;if eZ.sort_by then local dV,fz,fA;local fB=eZ.sort_by;local bg,bh=fB:find('%s+')if bg then fz,fA=fB:sub(1,bg-1),fB:sub(bh+1)else fz=fB;fA='asc'end;if fz:match'^%$'then fz=fz:sub(2)end;fz=fo(eR,fz)if fm then return nil,fm end;if fA=='asc'then fA='<'else fA='>'end;dV=('%s %s %s'):format(fz:gsub('v','v1'),fA,fz:gsub('v','v2'))fy=fy:gsub('SORT_EXPR',dV)end;if eZ.where then fy='return function(_condn) '..fy..' end'end;if eN then print(fy)end;local bq,bK=f.load(fy,'tmp')if not bq then return nil,bK end;bq=bq()if eZ.where then bq=bq(eZ.where)end;local fC=bq(eR)if fw then N(fw,_G)local fD={}f.setfenv(fC,fD)setmetatable(fD,{__index=function(dy,y)for bB,j in ipairs(fw)do if j[y]then return j[y]end end end})end;return fC end;eX.select=eR.query;eX.select_row=function(z,eZ,fw)return eR.query(z,eZ,fw,true)end;function eR.filter(fE,fF,fG,fH)local z=eR.read(fF or'stdin')local cA=f1(fG or'stdout')local aY,bK=z:select(fE)local bl=z.delim;if not aY then bK='error: '..bK;if fH then return nil,bK else f.quit(1,bK)end end;while true do local K={aY()}if#K==0 then break end;cA:write(aI(K,bl),'\n')end end;return eR end end;do local _ENV=_ENV;package.preload["pl.func"]=function(...)local a=_G.arg;local type,setmetatable,getmetatable,rawset=type,setmetatable,getmetatable,rawset;local aI,N=table.concat,table.insert;local tostring=tostring;local f=require'pl.utils'local pairs,rawget,unpack,fI=pairs,rawget,f.unpack,f.pack;local aK=require'pl.tablex'local bJ=aK.map;local eN=rawget(_G,'_DEBUG')local g=f.assert_arg;local fJ={}local fK={}local function fL(j)setmetatable(j,fK)return j end;fJ.PE=fL;local function fM(a_)return getmetatable(a_)==fK end;fJ.isPE=fM;local function fN(bi)return fL{op='X',repr='_'..bi,index=bi}end;local function fO(bi)return fL{op='X',repr='_C'..bi,index=bi}end;fJ._1,fJ._2,fJ._3,fJ._4,fJ._5=fN(1),fN(2),fN(3),fN(4),fN(5)fJ._0=fL{op='X',repr='...',index=0}function fJ.Var(a5)local b3=f.split(a5,'[%s,]+')local K={}for W=1,#b3 do N(K,fL{op='X',repr=b3[W],index=0})end;return unpack(K)end;function fJ._(bN)return fL{op='X',repr=bN,index='wrap'}end;local fP;fJ.Nil=fJ.Var'nil'function fK.__index(a_,y)return fL{op='[]',a_,y}end;function fK.__call(bn,...)return fL{op='()',bn,...}end;function fK.__tostring(dK)return fP(dK)end;function fK.__unm(a)return fL{op='unm',a}end;function fJ.Not(a)return fL{op='not',a}end;function fJ.Len(a)return fL{op='#',a}end;local function fQ(fw,j)for a5,ef in pairs(j)do rawset(fw,a5,function(b5,L)return fL{op=ef,b5,L}end)end end;local function fR(a5,bn,fw)rawset(fw,a5,function(...)return fL{op='()',bn,...}end)end;local fS={}local function fT(J)return type(_G[J])=='table'end;function fJ.import(fU,fw)g(1,fU,'string',fT,'arg# 1: not a name of a global table')local j=_G[fU]fw=fw or _G;for a5,bn in pairs(j)do fR(a5,bn,fw)fS[bn]=a5 end end;function fJ.register(bn,a5)g(1,bn,'function')if a5 then g(2,a5,'string')fS[bn]=a5 end;return function(...)return fL{op='()',bn,...}end end;function fJ.lookup_imported_name(bn)return fS[bn]end;local function fV(...)return...end;function fJ.Args(...)return fL{op='()',fV,...}end;local fW={['or']=0,['and']=2,['==']=4,['~=']=4,['<']=4,['>']=4,['<=']=4,['>=']=4,['..']=6,['+']=8,['-']=8,['*']=10,['/']=10,['%']=10,['^']=14}local fX={['not']=12,['#']=12,['unm']=12}fQ(fJ,{And='and',Or='or',Eq='==',Lt='<',Gt='>',Le='<=',Ge='>='})fQ(fK,{__add='+',__sub='-',__mul='*',__div='/',__mod='%',__pow='^',__concat='..'})fQ(fK,{__eq='=='})function fJ.tail(b3)g(1,b3,'table')local K={}for W=2,#b3 do N(K,b3[W])end;return K end;function fP(dK,fY)local fZ=fJ.tail;if fM(dK)then local e9=fW[dK.op]or fX[dK.op]if e9 then local ak;if fW[dK.op]then local f_=e9;local g0=e9;if dK.op=='..'or dK.op=='^'then f_=f_+1 else g0=g0+1 end;local g1=fP(dK[1],f_)local g2=fP(dK[2],g0)ak=g1 ..' '..dK.op..' '..g2 else local ef=dK.op=='unm'and'-'or dK.op;ak=ef..' '..fP(dK[1],e9)end;if fY and fY>e9 then ak='('..ak..')'end;return ak else local b3=bJ(fP,dK)if dK.op=='[]'then return b3[1]..'['..b3[2]..']'elseif dK.op=='()'then local bq;if b3[1]~=nil then bq=b3[1]else bq=''end;return bq..'('..aI(fZ(b3),',')..')'else return dK.repr end end elseif type(dK)=='string'then return'"'..dK..'"'elseif type(dK)=='function'then local a5=fJ.lookup_imported_name(dK)if a5 then return a5 else return tostring(dK)end else return tostring(dK)end end;fJ.repr=fP;local g3;function g3(dK,g4)if fM(dK)then if dK.op~='X'then local A=0;for W=1,#dK do local g5=dK[W]local g6=fM(g5)if g6 then if g5.op=='X'and g5.index=='wrap'then g5=g5.repr;g6=false else A=math.max(A,g3(g5,g4))end end;if not g6 then N(g4,g5)dK[W]=fO(#g4)end end;return A else return dK.index end else return 0 end end;fJ.collect_values=g3;function fJ.instantiate(dK)local g7,g8,fq={},{},{}local dJ,bK,bn;local J=fJ.collect_values(dK,g8)for W=1,#g8 do N(g7,'_C'..W)if eN then print(W,g8[W])end end;for W=1,J do N(fq,'_'..W)end;g7=aI(g7,',')fq=aI(fq,',')dJ=fP(dK)local g9=('return function(%s) return function(%s) return %s end end'):format(g7,fq,dJ)if eN then print(g9)end;bn,bK=f.load(g9,'fun')if not bn then return nil,bK end;bn=bn()bn=bn(unpack(g8))dK.__PE_function=bn;return bn end;function fJ.I(dK)if rawget(dK,'__PE_function')then return dK.__PE_function else return fJ.instantiate(dK)end end;f.add_function_factory(fK,fJ.I)fJ.bind1=f.bind1;fJ.curry=fJ.bind1;function fJ.compose(bp,ga)return function(...)return bp(ga(...))end end;function fJ.bind(bq,...)local ca=fI(...)local gb,fq,gc,g8={},{},{'fn'},{}local gd,ge,gf=1,0,false;for W=1,ca.n do local cm=ca[W]if fM(cm)and cm.op=='X'then N(gb,cm.repr)ge=math.max(ge,cm.index)if cm.index==0 then gf=true end else local a4='_v'..gd;N(gc,a4)N(gb,a4)N(g8,cm)gd=gd+1 end end;for gg=1,ge do N(fq,'_'..gg)end;if gf then N(fq,'...')end;gc=aI(gc,',')fq=aI(fq,',')gb=aI(gb,',')local g9=([[
return function (%s)
    return function(%s) return fn(%s) end
end
]]):format(gc,fq,gb)if eN then print(g9)end;local K=f.load(g9)K=K()return K(bq,unpack(g8))end;return fJ end end;do local _ENV=_ENV;package.preload["pl.import_into"]=function(...)local a=_G.arg;return function(dz)local gh;if dz==true then gh={}dz={}end;local dz=dz or{}local gi={utils=true,path=true,dir=true,tablex=true,stringio=true,sip=true,input=true,seq=true,lexer=true,stringx=true,config=true,pretty=true,data=true,func=true,text=true,operator=true,lapp=true,array2d=true,comprehension=true,xml=true,types=true,test=true,app=true,file=true,class=true,luabalanced=true,permute=true,template=true,url=true,compat=true,List=true,Map=true,Set=true,OrderedMap=true,MultiMap=true,Date=true}rawset(dz,'utils',require'pl.utils')for a5,b0 in pairs(dz.utils.stdmt)do b0.__index=function(j,y)return require('pl.'..a5)[y]end end;local gj,gk;local gl={}local gm=getmetatable(dz)if gm then gk=gm.__index;if gm.__newindex then gl.__index=gm.__newindex end end;function gl.hook(dx)gj=dx end;function gl.__index(j,a5)local gn=gi[a5]if gn then rawset(dz,a5,require('pl.'..a5))return dz[a5]else local K;if gj then K=gj(j,a5)if K then return K end end;if gk then return gk(j,a5)end end end;if gh then function gl.__newindex(j,a5,bN)gh[a5]=bN;rawset(j,a5,bN)end end;setmetatable(dz,gl)return dz,gh or dz end end end;do local _ENV=_ENV;package.preload["pl.input"]=function(...)local a=_G.arg;local go=string.find;local gp=string.sub;local gq=string.match;local f=require'pl.utils'local unpack=f.unpack;local pairs,type,tonumber=pairs,type,tonumber;local eO=f.patterns;local io=io;local gr={}function gr.alltokens(gs,gt,bq)local et=gs()local bO=1;return function()while et do local ak,dK=go(et,gt,bO)if ak then bO=dK+1;local K=gp(et,ak,dK)if bq then K=bq(K)end;return K else et=gs()bO=1 end end;return nil end end;local gu=gr.alltokens;function gr.create_getter(bp)if bp then if type(bp)=='string'then local b3=f.split(bp,'\n')local W,J=0,#b3;return function()W=W+1;if W>J then return nil end;return b3[W]end else if not bp.read then error('not a file-like object')end;return function()return bp:read()end end else return io.read end end;function gr.numbers(bp)return gu(gr.create_getter(bp),'('..eO.FLOAT..')',tonumber)end;function gr.words(bp)return gu(gr.create_getter(bp),"%w+")end;local function gv(gw,...)local ca={...}for W=1,#ca do local J=tonumber(ca[W])if J==nil then if not gw then return nil,ca[W]end else ca[W]=J end end;return ca end;function gr.fields(gx,bl,bp,gy)local dI;local ak;local gs=gr.create_getter(bp)local gw=gy and gy.no_fail;local gz=gy and gy.no_convert;if not bl or bl==' 'then bl='%s'dI='%s+'ak='%s*'else dI=bl;ak=''end;local gA=0;if type(gx)=='table'then for W,gB in pairs(gx)do if gB>gA then gA=gB end end else gA=gx;gx={}for W=1,gA do gx[#gx+1]=W end end;local gC='[^'..bl..']*'local bB=1;for W=1,gA do if gx[bB]==W then bB=bB+1;ak=ak..'('..gC..')'else ak=ak..gC end;if W<gA then ak=ak..dI end end;local gD=1;return function()local et,gE,bK;repeat et=gs()gD=gD+1;if not et then return nil end;if gz then gE={gq(et,ak)}else gE,bK=gv(gw,gq(et,ak))if not gE then f.quit("line "..gD-1 ..": cannot convert '"..bK.."' to number")end end until#gE>0;return unpack(gE)end end;return gr end end;do local _ENV=_ENV;package.preload["pl.lapp"]=function(...)local a=_G.arg;local dP,gF=pcall(require,'pl.sip')if not dP then gF=require'sip'end;local gG=gF.match_at_start;local N,aG=table.insert,table.insert;gF.custom_pattern('X','(%a[%w_%-]*)')local function gH(ak)return ak:gmatch('([^\n]*)\n')end;local function gI(a2)return a2:gsub('^%s+','')end;local function ep(a2)return gI(a2):gsub('%s+$','')end;local function gJ(ak,bB)return ak:sub(bB,bB)end;local gK={}local gL,fq,gM,gN,gO,gP;gK.callback=false;local gQ={stdin={io.stdin,'file-in'},stdout={io.stdout,'file-out'},stderr={io.stderr,'file-out'}}gK.show_usage_error=true;function gK.quit(gR,gS)if gS=='throw'then error(gR)end;if gR then io.stderr:write(gR..'\n\n')end;if not gS then io.stderr:write(gO)end;os.exit(1)end;function gK.error(gR,gS)if not gK.show_usage_error then gS=true elseif gK.show_usage_error=='throw'then gS='throw'end;gK.quit(gP..': '..gR,gS)end;function gK.open(c5,gT)local v,bK=io.open(c5,gT)if not v then gK.error(bK,true)end;N(gL,v)return v end;function gK.assert(eZ,gR)if not eZ then gK.error(gR)end end;local function gU(b5,ax,d5,gV)gK.assert(ax<=b5 and d5>=b5,gV..' out of range')end;local function gW(ak)local v=tonumber(ak)if not v then gK.error("unable to convert to number: "..ak)end;return v end;local cp={}local gX={string=true,number=true,['file-in']='file',['file-out']='file',boolean=true}local function gY(gZ,v)if gZ.converter then v=gZ.converter(v)end;if gZ.type=='number'then v=gW(v)elseif gX[gZ.type]=='file'then v=gK.open(v,gZ.type=='file-in'and'r'or'w')elseif gZ.type=='boolean'then return v end;if gZ.constraint then gZ.constraint(v)end;return v end;function gK.add_type(a5,g_,h0)cp[a5]={converter=g_,constraint=h0}end;local function h1(h2)gK.assert(#h2==1,h2 ..": short parameters should be one character")end;local function h3(h4,h5)local v,h6;if not h5 or h5=='number'then v=tonumber(h4)end;if v then return v,'number'elseif gQ[h4]then local h7=gQ[h4]return h7[1],h7[2]else if h4=='true'and not h5 then return true,'boolean'end;if h4:match'^["\']'then h4=h4:sub(2,-2)end;local gZ=cp[h5]or{}gZ.type=h5;local h8=gK.show_usage_error;gK.show_usage_error="throw"h6,v=pcall(gY,gZ,h4)gK.show_usage_error=h8;if h6 then return v,h5 or'string'end;return h4,h5 or'string'end end;function gK.process_options_string(a2,ca)local gE={}local gf;local a=ca or _G.arg;gL={}fq={}gM={}gN={}local function h9(ak)local K,_=ak:gsub('^%.%.%.%s*','')return K,_>0 end;local function ha(gZ,gV,v)gV=type(gV)=="string"and gV:gsub("%W","_")or gV;if not gZ.varargs then gE[gV]=v else if not gE[gV]then gE[gV]={v}else N(gE[gV],v)end end end;gO=a2;for t,cm in ipairs(a)do if cm=="-h"or cm=="--help"then return gK.quit()end end;for et in gH(a2)do local K={}local hb,hc,h5,h0,hd;et=gI(et)local function he(a2)return gG(a2,et,K)end;if he'-$v{short}, --$o{long} $'or he'-$v{short} $'or he'--$o{long} $'then if K.long then hb=K.long:gsub('[^%w%-]','_')if#K.rest==1 then hb=hb..K.rest end;if K.short then gM[K.short]=hb end else hb=K.short end;if K.short and not gK.slack then h1(K.short)end;K.rest,gf=h9(K.rest)elseif he'$<{name} $'then hb,hd=K.name:match'([^%.]+)(.*)'hb=hb:gsub('%A','_')gf=hd=='...'N(gN,hb)end;if K.rest then et=K.rest;K={}local hf;if gG('$({def} $',et,K)or gG('$({def}',et,K)then local hg=ep(K.def)local hh,hd=hg:match('^(%S+)(.*)$')hd=ep(hd)if hh=='optional'then hh,hd=hd:match('^(%S+)(.*)$')hd=ep(hd)hf=true end;local bE;if hh=='default'then bE=true;if hd==''then gK.error("value must follow default")end else if gG('$f{min}..$f{max}',hh,K)then local ax,d5=K.min,K.max;h5='number'h0=function(b5)gU(b5,ax,d5,hb)end elseif not hh:match'|'then h5=hh else local hi=hh;local hj='|'..hi..'|'h5='string'h0=function(ak)gK.assert(hj:match('|'..ak..'|'),"value '"..ak.."' not in "..hi)end end end;K.rest=hd;hg=K.rest;if bE or gG('default $r{rest}',hg,K)then hc,h5=h3(K.rest,h5)end else hc=false;h5='boolean'end;local gZ={type=h5,defval=hc,required=hc==nil and not hf,comment=K.rest or hb,constraint=h0,varargs=gf}gf=nil;if cp[h5]then local g_=cp[h5].converter;if type(g_)=='string'then gZ.type=g_ else gZ.converter=g_ end;gZ.constraint=cp[h5].constraint elseif not gX[h5]and h5 then gK.error(h5 .." is unknown type")end;fq[hb]=gZ end end;local hk=1;local hl=1;local W=1;local gV,gZ,v;local hm=false;local function hn(gV)local ho=gV:find'[=:]'if ho then aG(a,W+1,gV:sub(ho+1))gV=gV:sub(1,ho-1)end;return gV,ho end;local function hp(gV)return fq[gM[gV]or gV]end;while W<=#a do local hq=a[W]local K={}if hq=='--'then hm=true;hk=#gN+1;W=W+1;hq=a[W]if not hq then break end end;if not hm and(gG('--$S{long}',hq,K)or gG('-$S{short}',hq,K))then if K.long then gV=hn(K.long)elseif#K.short==1 or hp(K.short)then gV=K.short else local hr,hs=hn(K.short)if not hs then gV=gJ(hr,1)local ht=hp(gV)if ht and ht.type~='boolean'then aG(a,W+1,hr:sub(2))else for bB=2,#hr do aG(a,W+bB-1,'-'..gJ(hr,bB))end end else gV=hr end end;if gM[gV]then gV=gM[gV]end;if not fq[gV]and(gV=='h'or gV=='help')then gK.quit()end else gV=gN[hk]if not gV then gV=hl;gZ={type='string'}fq[gV]=gZ;hl=hl+1 else gZ=fq[gV]end;if not gZ.varargs then hk=hk+1 end;v=hq end;gZ=fq[gV]if not gZ then gK.error("unrecognized parameter: "..gV)end;if gZ.type~='boolean'then if not v then W=W+1;v=a[W]hq=v end;gK.assert(v,gV.." was expecting a value")else v=not gZ.defval end;gZ.used=true;v=gY(gZ,v)ha(gZ,gV,v)if gX[gZ.type]=='file'then ha(gZ,gV..'_name',hq)end;if gK.callback then gK.callback(gV,hq,K)end;W=W+1;v=nil end;for gV,gZ in pairs(fq)do if not gZ.used then if gZ.required then gK.error("missing required parameter: "..gV)end;ha(gZ,gV,gZ.defval)end end;return gE end;if a then gP=a[0]gP=gP or rawget(_G,"LAPP_SCRIPT")or"unknown"gP=gP:gsub('.+[\\/]',''):gsub('%.%a+$','')else gP="inter"end;setmetatable(gK,{__call=function(dy,a2,ca)return gK.process_options_string(a2,ca)end})return gK end end;do local _ENV=_ENV;package.preload["pl.lexer"]=function(...)local a=_G.arg;local go=string.find;local gp=string.sub;local N=table.insert;local function g(bi,v,hu)if type(v)~=hu then error("argument "..bi.." must be "..hu,2)end end;local hv={}local hw='^[%+%-]?%d+%.?%d*[eE][%+%-]?%d+'local hx='^[%+%-]?%d*%.%d+[eE][%+%-]?%d+'local hy='^[%+%-]?%d+%.?%d*'local hz='^[%+%-]?%d*%.%d+'local hA='^0x[%da-fA-F]+'local hB='^%d+%.?%d*[eE][%+%-]?%d+'local hC='^%d*%.%d+[eE][%+%-]?%d+'local hD='^%d+%.?%d*'local hE='^%d*%.%d+'local hF='^[%a_][%w_]*'local hG='^%s+'local hH="^(['\"])%1"local hI=[[^(['"])(\*)%2%1]]local hJ=[[^(['"]).-[^\](\*)%2%1]]local hK="^''"local hL=[[^'(\*)%1']]local hM=[[^'.-[^\](\*)%1']]local hN='^#.-[^\\]\n'local hO,hP,hQ,hR,hS;local function hT(dX)return dX,dX end;local function hU(dX,hV)if hV and hV.number then dX=tonumber(dX)end;return"number",dX end;local function hW(dX,hV)if hV and hV.string then dX=dX:sub(2,-2)end;return"string",dX end;local function hX(dX,hV,hY)if hV and hV.string then local hZ=3;if hY[3]then hZ=hZ+hY[3]:len()end;dX=dX:sub(hZ,-hZ)if dX:sub(1,1)=="\n"then dX=dX:sub(2)end end;return"string",dX end;local function h_(dX,hV)if hV and hV.string then dX=dX:sub(2,-2)end;return"char",dX end;local function i0(dX)return"comment",dX end;local function i1(dX)return"space",dX end;local function i2(dX)return"prepro",dX end;local function i3(dX)return"iden",dX end;local function i4(dX)if hR[dX]then return"keyword",dX else return"iden",dX end end;local function i5(dX)if hS[dX]then return"keyword",dX else return"iden",dX end end;function hv.scan(ak,i6,aL,hV)local c5=type(ak)~='string'and ak;aL=aL or{space=true}hV=hV or{number=true,string=true}if aL then if aL.space then aL[i1]=true end;if aL.comments then aL[i0]=true end end;if not i6 then if not hO then hO={{hG,i1},{hA,hU},{hF,i3},{hw,hU},{hx,hU},{hy,hU},{hz,hU},{hH,hW},{hI,hW},{hJ,hW},{'^.',hT}}end;i6=hO end;local i7=0;local i8=c5 and c5:read()local i9=c5 and 0 or#ak;local bi=1;local ia;local ib;local ic=true;local function aY(K)local hu=type(K)if ib then local id=ib[ia]if id then ia=ia+1;return id[1],id[2]else ib=nil end end;if hu=='string'then local bg,bh=go(ak,K,bi)if bg then local dX=gp(ak,bg,bh)bi=bh+1;return'',dX else bi=i9+1;return'',''end elseif hu=='table'then ia=1;ib=K;return'',''elseif hu~='nil'then return i7,bi else if ic then if not c5 then i7=1 end;ic=false end;if bi>i9 then if c5 then if not i8 then return end;ak=i8;i7=i7+1;i8=c5:read()if i8 then ak=ak..'\n'end;bi,i9=1,#ak else return end end;for t,A in ipairs(i6)do local gC=A[1]local bn=A[2]local hY={go(ak,gC,bi)}local bg,bh=hY[1],hY[2]if bg then local dX=gp(ak,bg,bh)bi=bh+1;local ie,ig;if not(aL and aL[bn])then hv.finished=bi>i9;ie,ig=bn(dX,hV,hY)end;if not c5 and dX:find("\n")then local t,ih=dX:gsub("\n",{})i7=i7+ih end;if ie then return ie,ig else return aY()end end end end end;return aY end;local function ii(ak)return type(ak)=='string'end;function hv.insert(dX,ij,ik)if not ij then return end;local p;if ii(ij)and ii(ik)then p={{ij,ik}}elseif type(ij)=='function'then p={}for j,a4 in ij()do N(p,{j,a4})end else p=ij end;dX(p)end;function hv.getline(dX)local t,a4=dX('.-\n')return a4 end;function hv.lineno(dX)return dX(0)end;function hv.getrest(dX)local t,a4=dX('.+')return a4 end;function hv.get_keywords()if not hR then hR={["and"]=true,["break"]=true,["do"]=true,["else"]=true,["elseif"]=true,["end"]=true,["false"]=true,["for"]=true,["function"]=true,["if"]=true,["in"]=true,["local"]=true,["nil"]=true,["not"]=true,["or"]=true,["repeat"]=true,["return"]=true,["then"]=true,["true"]=true,["until"]=true,["while"]=true}end;return hR end;function hv.lua(ak,aL,hV)aL=aL or{space=true,comments=true}hv.get_keywords()if not hP then hP={{hG,i1},{hA,hU},{hF,i4},{hB,hU},{hC,hU},{hD,hU},{hE,hU},{hH,hW},{hI,hW},{hJ,hW},{'^%-%-%[(=*)%[.-%]%1%]',i0},{'^%-%-.-\n',i0},{'^%[(=*)%[.-%]%1%]',hX},{'^==',hT},{'^~=',hT},{'^<=',hT},{'^>=',hT},{'^%.%.%.',hT},{'^%.%.',hT},{'^.',hT}}end;return hv.scan(ak,hP,aL,hV)end;function hv.cpp(ak,aL,hV)aL=aL or{space=true,comments=true}if not hS then hS={["class"]=true,["break"]=true,["do"]=true,["sizeof"]=true,["else"]=true,["continue"]=true,["struct"]=true,["false"]=true,["for"]=true,["public"]=true,["void"]=true,["private"]=true,["protected"]=true,["goto"]=true,["if"]=true,["static"]=true,["const"]=true,["typedef"]=true,["enum"]=true,["char"]=true,["int"]=true,["bool"]=true,["long"]=true,["float"]=true,["true"]=true,["delete"]=true,["double"]=true,["while"]=true,["new"]=true,["namespace"]=true,["try"]=true,["catch"]=true,["switch"]=true,["case"]=true,["extern"]=true,["return"]=true,["default"]=true,['unsigned']=true,['signed']=true,["union"]=true,["volatile"]=true,["register"]=true,["short"]=true}end;if not hQ then hQ={{hG,i1},{hN,i2},{hA,hU},{hF,i5},{hB,hU},{hC,hU},{hD,hU},{hE,hU},{hK,h_},{hL,h_},{hM,h_},{hH,hW},{hI,hW},{hJ,hW},{'^//.-\n',i0},{'^/%*.-%*/',i0},{'^==',hT},{'^!=',hT},{'^<=',hT},{'^>=',hT},{'^->',hT},{'^&&',hT},{'^||',hT},{'^%+%+',hT},{'^%-%-',hT},{'^%+=',hT},{'^%-=',hT},{'^%*=',hT},{'^/=',hT},{'^|=',hT},{'^%^=',hT},{'^::',hT},{'^.',hT}}end;return hv.scan(ak,hQ,aL,hV)end;function hv.get_separated_list(dX,il,bl)il=il or')'bl=bl or','local im={}local ip=1;local iq={}local function ir(iq,j,v)v=v or j;N(iq,{j,v})end;local is;if il=='\n'then is=function(j,v)return j=='space'and v:find'\n'end else is=function(j)return j==il end end;local it,bN;while true do it,bN=dX()if not it then return nil,'EOS'end;if is(it,bN)and ip==1 then N(im,iq)break elseif it=='('then ip=ip+1;ir(iq,'(')elseif it==')'then ip=ip-1;if ip==0 then N(im,iq)break else ir(iq,')')end elseif it==bl and ip==1 then N(im,iq)iq={}else ir(iq,it,bN)end end;return im,{it,bN}end;function hv.skipws(dX)local j,a4=dX()while j=='space'do j,a4=dX()end;return j,a4 end;local iu=hv.skipws;function hv.expecting(dX,iv,iw)g(1,dX,'function')g(2,iv,'string')local j,a4;if iw then j,a4=dX()else j,a4=iu(dX)end;if j~=iv then error("expecting "..iv,2)end;return a4 end;return hv end end;do local _ENV=_ENV;package.preload["pl.luabalanced"]=function(...)local a=_G.arg;local ix={}local assert=assert;local iy={['(']=')',['{']='}',['[']=']'}local iz={}for bB,a4 in pairs(iy)do iz[a4]=bB end;local function iA(ak,bO)bO=bO or 1;local iB=bO;local u=ak:sub(bO,bO)if u=='"'or u=="'"then bO=bO+1;while 1 do bO=assert(ak:find("["..u.."\\]",bO),'syntax error')if ak:sub(bO,bO)==u then local iC=ak:sub(iB,bO)return iC,bO+1 else bO=bO+2 end end else local iD=ak:match("^%[(=*)%[",bO)if iD then local t;t,bO=ak:find("%]"..iD.."%]",bO)assert(bO)local iC=ak:sub(iB,bO)return iC,bO+1 else return nil,bO end end end;ix.match_string=iA;local function iE(ak,bO)bO=bO or 1;local iB=bO;local iF=ak:sub(bO,bO)if not iy[iF]then return nil,bO end;local iG={}while 1 do bO=ak:find('[%(%{%[%)%}%]\"\']',bO)assert(bO,'syntax error: unbalanced')local u=ak:sub(bO,bO)if u=='"'or u=="'"then local iC;iC,bO=iA(ak,bO)assert(iC)elseif iy[u]then local iH,e0;if u=='['then iH,e0=ak:match('^%[(=*)%[()',bO)end;if iH then bO=ak:match('%]'..iH..'%]()',e0)assert(bO,'syntax error: long string not terminated')if#iG==0 then local iC=ak:sub(iB,bO-1)return iC,bO end else iG[#iG+1]=u;bO=bO+1 end else assert(iG[#iG]==assert(iz[u]),'syntax error: unbalanced')iG[#iG]=nil;if#iG==0 then local iC=ak:sub(iB,bO)return iC,bO+1 end;bO=bO+1 end end end;ix.match_bracketed=iE;local function iI(ak,bO)bO=bO or 1;if ak:sub(bO,bO+1)~='--'then return nil,bO end;bO=bO+2;local iJ,dY=iA(ak,bO)if iJ then return'--'..iJ,dY end;local iC;iC,bO=ak:match('^([^\n]*\n?)()',bO)return'--'..iC,bO end;local iK={['and']=true,['or']=true,['not']=true}local iL={['>']=true,['<']=true,['~']=true}local function iM(ak,bO)bO=bO or 1;local t;local iB=bO;local iN;local iO,iP;while bO do local u=ak:sub(bO,bO)if u=='"'or u=="'"or u=='['and ak:find('^[=%[]',bO+1)then local iC;iC,bO=iA(ak,bO)assert(iC,'syntax error')elseif u=='-'and ak:sub(bO+1,bO+1)=='-'then iO=bO;while ak:sub(bO,bO+1)=='--'do local iC;iC,bO=iI(ak,bO)assert(iC)bO=ak:match('^%s*()',bO)iP=bO end elseif u=='('or u=='{'or u=='['then t,bO=iE(ak,bO)elseif u=='='and ak:sub(bO+1,bO+1)=='='then bO=bO+2 elseif u=='='and iL[ak:sub(bO-1,bO-1)]then bO=bO+1 elseif u:match'^[%)%}%];,=]'then local iC=ak:sub(iB,bO-1)return iC,bO elseif u:match'^[%w_]'then local iQ,iR=ak:match('^([%w_]+)()',bO)if bO~=iB and not iK[iQ]then local dZ=(iP==bO and iO or bO)-1;while ak:match('^%s',dZ)do dZ=dZ-1 end;local iS=ak:sub(dZ,dZ)if iS:match'[%)%}\'\"%]]'or iS:match'[%w_]'and not iK[iN]then local iC=ak:sub(iB,bO-1)return iC,bO end end;iN,bO=iQ,iR else bO=bO+1 end;bO=ak:find('[%(%{%[%)%}%]\"\';,=%w_%-]',bO)end;local iC=ak:sub(iB,#ak)return iC,#ak+1 end;ix.match_expression=iM;local function iT(ak,bO)bO=bO or 1;local bj={}while 1 do local u=#bj==0 and'^'or'^%s*,%s*'local iU,dY=ak:match(u..'([%a_][%w_]*)%s*()',bO)if iU then bO=dY else break end;bj[#bj+1]=iU end;return bj,bO end;ix.match_namelist=iT;local function iV(ak,bO)bO=bO or 1;local bj={}while 1 do if#bj~=0 then local dY=ak:match('^%s*,%s*()',bO)if dY then bO=dY else break end end;local iU;iU,bO=iM(ak,bO)assert(iU,'syntax error')bj[#bj+1]=iU end;return bj,bO end;ix.match_explist=iV;local function eQ(ak,bp)local bO=1;local iB=1;local iW=''while 1 do bO=ak:find('[%-\'\"%[]',bO)if not bO then break end;if ak:match('^%-%-',bO)then local iX=ak:sub(iB,bO-1)if#iX>0 then iW=iW..(bp('e',iX)or iX)end;local iY;iY,bO=iI(ak,bO)iW=iW..(bp('c',assert(iY))or iY)iB=bO else local e0=ak:find('^[\'\"%[]',bO)local a2;if e0 then a2,bO=iA(ak,e0)end;if a2 then local iX=ak:sub(iB,e0-1)if#iX>0 then iW=iW..(bp('e',iX)or iX)end;iW=iW..(bp('s',a2)or a2)iB=bO else bO=bO+1 end end end;local iX=ak:sub(iB)if#iX>0 then iW=iW..(bp('e',iX)or iX)end;return iW end;ix.gsub=eQ;return ix end end;do local _ENV=_ENV;package.preload["pl.operator"]=function(...)local a=_G.arg;local go=string.find;local iZ={}function iZ.call(bq,...)return bq(...)end;function iZ.index(j,bB)return j[bB]end;function iZ.eq(cm,cL)return cm==cL end;function iZ.neq(cm,cL)return cm~=cL end;function iZ.lt(cm,cL)return cm<cL end;function iZ.le(cm,cL)return cm<=cL end;function iZ.gt(cm,cL)return cm>cL end;function iZ.ge(cm,cL)return cm>=cL end;function iZ.len(cm)return#cm end;function iZ.add(cm,cL)return cm+cL end;function iZ.sub(cm,cL)return cm-cL end;function iZ.mul(cm,cL)return cm*cL end;function iZ.div(cm,cL)return cm/cL end;function iZ.pow(cm,cL)return cm^cL end;function iZ.mod(cm,cL)return cm%cL end;function iZ.concat(cm,cL)return cm..cL end;function iZ.unm(cm)return-cm end;function iZ.lnot(cm)return not cm end;function iZ.land(cm,cL)return cm and cL end;function iZ.lor(cm,cL)return cm or cL end;function iZ.table(...)return{...}end;function iZ.match(cm,cL)return go(cm,cL)~=nil end;function iZ.nop(...)return...end;iZ.optable={['+']=iZ.add,['-']=iZ.sub,['*']=iZ.mul,['/']=iZ.div,['%']=iZ.mod,['^']=iZ.pow,['..']=iZ.concat,['()']=iZ.call,['[]']=iZ.index,['<']=iZ.lt,['<=']=iZ.le,['>']=iZ.gt,['>=']=iZ.ge,['==']=iZ.eq,['~=']=iZ.neq,['#']=iZ.len,['and']=iZ.land,['or']=iZ.lor,['{}']=iZ.table,['~']=iZ.match,['']=iZ.nop}return iZ end end;do local _ENV=_ENV;package.preload["pl.permute"]=function(...)local a=_G.arg;local aK=require'pl.tablex'local f=require'pl.utils'local fi=aK.deepcopy;local N=table.insert;local g=f.assert_arg;local i_={}function i_.order_iter(cm)g(1,cm,'table')local j=#cm;local iG={1}local function aY()local G=#iG;local J=j-G+1;local W=iG[G]if W>j then return end;if J==0 then table.remove(iG)G=G-1;iG[G]=iG[G]+1;return cm elseif W<=J then cm[J],cm[W]=cm[W],cm[J]table.insert(iG,1)else table.remove(iG)G=G-1;J=J+1;W=iG[G]cm[J],cm[W]=cm[W],cm[J]iG[G]=iG[G]+1 end;return aY()end;return aY end;function i_.order_table(cm)g(1,cm,'table')local K={}for j in i_.iter(cm)do N(K,fi(j))end;return K end;function i_.list_iter(...)local j0={...}local j1={}local j2={}local j3=#j0;for W,bj in ipairs(j0)do g(W,bj,'table')j1[W]=1;j2[W]=bj.n or#bj end;local f4=0;return function()if j1[j3]>j2[j3]then return end;f4=f4+1;local cF={n=#j0}local j4=true;for W=1,j3 do cF[W]=j0[W][j1[W]]if j4 then j1[W]=j1[W]+1;if j1[W]<=j2[W]then j4=false else if W~=j3 then j1[W]=1 end end end end;return f4,f.unpack(cF)end end;function i_.list_table(...)local aY=i_.list_iter(...)local gE={}local W=1;while true do local g8=f.pack(aY())if g8[1]==nil then return gE end;for W=1,g8.n do g8[W]=g8[W+1]end;g8.n=g8.n-1;gE[W]=g8;W=W+1 end end;function i_.iter(...)f.raise_deprecation{source="Penlight "..f._VERSION,message="function 'iter' was renamed to 'order_iter'",version_removed="2.0.0",deprecated_after="1.9.2"}return i_.order_iter(...)end;function i_.table(...)f.raise_deprecation{source="Penlight "..f._VERSION,message="function 'table' was renamed to 'order_table'",version_removed="2.0.0",deprecated_after="1.9.2"}return i_.order_table(...)end;return i_ end end;do local _ENV=_ENV;package.preload["pl.pretty"]=function(...)local a=_G.arg;local N=table.insert;local aI=table.concat;local j5,j6=math.floor,math.huge;local j7=math.type;local f=require'pl.utils'local hv=require'pl.lexer'local debug=require'debug'local j8=require'pl.stringx'.quote_string;local g=f.assert_arg;local j9=tostring;local function tostring(bN)if type(bN)~="number"then return j9(bN)elseif bN~=bN then return"NaN"elseif bN==j6 then return"Inf"elseif bN==-j6 then return"-Inf"elseif(_VERSION~="Lua 5.3"or j7(bN)=="integer")and j5(bN)==bN then return("%d"):format(bN)else local K=("%.14g"):format(bN)if _VERSION=="Lua 5.3"and j7(bN)=="float"and not K:find("%.")then K=K:gsub("%d+","%0.0",1)end;return K end end;local ja={}local function jb()local dz={}dz.hook,dz.mask,dz.count=debug.gethook()if dz.hook~="external hook"then debug.sethook()end;dz.string_mt=getmetatable("")debug.setmetatable("",nil)return dz end;local function jc(dz)if dz then debug.setmetatable("",dz.string_mt)if dz.hook~="external hook"then debug.sethook(dz.hook,dz.mask,dz.count)end end end;function ja.read(ak)g(1,ak,'string')if ak:find'^%s*%-%-'then ak=ak:gsub('%-%-.-\n','')end;if not ak:find'^%s*{'then return nil,"not a Lua table"end;if ak:find'[^\'"%w_]function[^\'"%w_]'then local dX=hv.lua(ak)for j,a4 in dX do if j=='keyword'and a4=='function'then return nil,"cannot have functions in table definition"end end end;ak='return '..ak;local dG,bK=f.load(ak,'tbl','t',{})if not dG then return nil,bK end;local jd=jb()local aF,c9=pcall(dG)jc(jd)if aF then return c9 else return nil,c9 end end;function ja.load(ak,dz,je)dz=dz or{}if je then local dX=hv.lua(ak)for j,a4 in dX do if j=='keyword'and(a4=='for'or a4=='repeat'or a4=='function'or a4=='goto')then return nil,"looping not allowed"end end end;local dG,bK=f.load(ak,'tbl','t',dz)if not dG then return nil,bK end;local jd=je and jb()local aF,bK=pcall(dG)jc(jd)if not aF then return nil,bK end;return dz end;local function jf(a4)if not a4 then return''else if a4:find' 'then a4=j8(a4)end end;return a4 end;local jg;local function jh(ak)return type(ak)=='string'and ak:find('^[%a_][%w_]*$')and not jg[ak]end;local function ji(ak)if type(ak)=='table'then return ja.write(ak,'')else return j8(ak)end end;local function cB(jj,y)if not jj then y=ji(y)y=y:find("^%[")and" "..y.." "or y end;return'['..y..']'end;function ja.write(dy,jk,jl)if type(dy)~='table'then local K=tostring(dy)if type(dy)=='string'then return ji(dy)end;return K,'not a table'end;if not jg then jg=hv.get_keywords()end;local bU=' = 'if jk==''then bU='='end;jk=jk or'  'local gH={}local et=''local jm={}local function jn(ak)if#ak>0 then et=et..ak end end;local function jo(ak)if#et>0 then et=et..ak;N(gH,et)et=''else N(gH,ak)end end;local function jp()local J=#gH;local jq=gH[J]:sub(-1,-1)if jq==','then gH[J]=gH[J]:sub(1,-2)end end;local ipairs=function(j)local W=0;local aF,a4;local gs=function()return j[W]end;return function()W=W+1;aF,a4=pcall(gs)if a4==nil or not aF then return end;return W,j[W]end end;local pairs=function(j)local bB,a4,aF;local gs=function()return next(j,bB)end;return function()aF,bB,a4=pcall(gs)if not aF then return end;return bB,a4 end end;local jr;jr=function(j,js,jt)local hu=type(j)if hu~='string'and hu~='table'then jo(jf(tostring(j))..',')elseif hu=='string'then jo(j8(j)..",")elseif hu=='table'then if jm[j]then jo('<cycle>,')return end;jm[j]=true;local ju=jt..jk;jo('{')local T={}if not jl then for W,v in ipairs(j)do jn(jt)jr(v,jt,ju)T[W]=true end end;local jv={}for bB,a4 in pairs(j)do if type(bB)~='number'then jv[#jv+1]=bB end end;table.sort(jv,function(cm,cL)if type(cm)==type(cL)and type(cm)=='string'then return cm<cL end;return type(cm)=='boolean'or type(cL)~='boolean'and type(cm)=='table'end)local function jw(y,v)local jx=type(y)local jj=jx=='number'if jl then y=tostring(y)jn(jt..cB(jj,y)..bU)jr(v,jt,ju)else if not jj or not T[y]then if jx~='string'then y=tostring(y)end;if jj or not jh(y)then y=cB(jj,y)end;jn(jt..y..bU)jr(v,jt,ju)end end end;for W=1,#jv do local y=jv[W]local v=j[y]jw(y,v)end;for y,v in pairs(j)do if type(y)=='number'then jw(y,v)end end;jm[j]=nil;jp()jo(js..'},')else jo(tostring(j)..',')end end;jr(dy,'',jk)jp()return aI(gH,#jk>0 and'\n'or'')end;function ja.dump(j,jy)if not jy then print(ja.write(j))return true else return f.writefile(jy,ja.write(j))end end;function ja.debug(...)local J=select("#",...)local j={...}for W=1,J do local bN=j[W]if bN==nil then bN="<nil>"end;j[W]=nil;j["arg "..W]=bN end;print(ja.write(j))return true end;local jz,jA={'B','KiB','MiB','GiB'},{'','K','M','B'}local function jB(v)local jC=math.floor(v/1000)if jC>0 then return jB(jC)..','..tostring(v%1000)else return tostring(v)end end;function ja.number(jD,an,jE)local D='%.'..(jE or 1)..'f%s'if an=='T'then return jB(jD)else local jF,jG;if an=='M'then jG=1024;jF=jz else jG=1000;jF=jA end;local jH=jG;local bB=1;while jD>=jH and bB<=#jF do jH=jH*jG;bB=bB+1 end;jH=jH/jG;if bB>#jF then bB=bB-1;jH=jH/jG end;if bB>1 then return D:format(jD/jH,jF[bB]or'duh')else return jD..jF[1]end end end;return setmetatable(ja,{__call=function(self,...)return self.debug(...)end})end end;do local _ENV=_ENV;package.preload["pl.seq"]=function(...)local a=_G.arg;local next,assert,pairs,tonumber,type,setmetatable=next,assert,pairs,tonumber,type,setmetatable;local go,jI=string.find,string.format;local jJ=math.random;local aJ,ir=table.sort,table.insert;local io=io;local f=require'pl.utils'local jK=require'pl.types'.is_callable;local aU=f.function_arg;local g=f.assert_arg;local debug=require'debug'local bk={}function bk.greater_than(b5)return function(a4)return tonumber(a4)>b5 end end;function bk.less_than(b5)return function(a4)return tonumber(a4)<b5 end end;function bk.equal_to(b5)if type(b5)=="number"then return function(a4)return tonumber(a4)==b5 end else return function(a4)return a4==b5 end end end;function bk.matching(ak)return function(a4)return go(a4,ak)end end;local jL;function bk.list(j)g(1,j,'table')if not jL then jL=ipairs{}end;local y,bN=0;return function()y,bN=jL(j,y)return bN end end;function bk.keys(j)g(1,j,'table')local y;return function()y=next(j,y)return y end end;local bj=bk.list;local function jM(aY)if type(aY)=='table'then return bj(aY)else return aY end end;bk.iter=jM;function bk.range(bd,be)local W=bd-1;return function()W=W+1;if W>be then return nil else return W end end end;function bk.count(aY,eZ,a)local W=0;bk.foreach(aY,function(v)if eZ(v,a)then W=W+1 end end)return W end;function bk.minmax(aY)local b8,b9=1e70,-1e70;for a4 in jM(aY)do a4=tonumber(a4)if a4<b8 then b8=a4 end;if a4>b9 then b9=a4 end end;return b8,b9 end;function bk.sum(aY,bq)local ak=0;local W=0;for a4 in jM(aY)do if bq then a4=bq(a4)end;ak=ak+a4;W=W+1 end;return ak,W end;function bk.copy(aY)local K,bB={},1;for a4 in jM(aY)do K[bB]=a4;bB=bB+1 end;setmetatable(K,require('pl.List'))return K end;function bk.copy2(aY,bg,bh)local K,bB={},1;for jN,jO in aY,bg,bh do K[bB]={jN,jO}bB=bB+1 end;return K end;function bk.copy_tuples(aY)aY=jM(aY)local K={}local cE={aY()}while#cE>0 do ir(K,cE)cE={aY()}end;return K end;function bk.random(J,eu,eb)local jP;assert(type(J)=='number')if eb then jP=function()return jJ(eu,eb)end elseif eu then jP=function()return jJ(eu)end else jP=jJ end;return function()if J==0 then return nil else J=J-1;return jP()end end end;function bk.sort(aY,jQ)local j=bk.copy(aY)aJ(j,jQ)return bj(j)end;function bk.zip(jR,jS)jR=jM(jR)jS=jM(jS)return function()return jR(),jS()end end;function bk.count_map(aY)local j={}local a4;for ak in jM(aY)do a4=j[ak]if a4 then j[ak]=a4+1 else j[ak]=1 end end;return setmetatable(j,require('pl.Map'))end;function bk.unique(aY,jT)local j=bk.count_map(aY)local K,bB={},1;for y in pairs(j)do K[bB]=y;bB=bB+1 end;table.sort(K)if jT then return K else return bj(K)end end;function bk.printall(aY,dI,fe,D)local jU=io.write;if not dI then dI=' 'end;if not fe then if dI=='\n'then fe=1e30 else fe=7 end end;if D then local g9=D;D=function(a4)return jI(g9,a4)end end;local bB=1;for a4 in jM(aY)do if D then a4=D(a4)end;if bB<fe then jU(a4,dI)bB=bB+1 else jU(a4,'\n')bB=1 end end;jU'\n'end;function bk.splice(jR,jS)jR=jM(jR)jS=jM(jS)local aY=jR;return function()local c9=aY()if c9==nil then if aY==jR then aY=jS;return aY()else return nil end else return c9 end end end;function bk.map(bq,aY,a)bq=aU(1,bq)aY=jM(aY)return function()local jN,jO=aY()if jN==nil then return nil end;return bq(jN,a or jO)or false end end;function bk.filter(aY,e9,a)e9=aU(2,e9)return function()local jN,jO;while true do jN,jO=aY()if jN==nil then return nil end;if e9(jN,a or jO)then return jN,jO end end end end;function bk.reduce(bq,aY,jV)bq=aU(1,bq)aY=jM(aY)local v=jV or aY()if v==nil then return nil end;for a4 in aY do v=bq(v,a4)end;return v end;function bk.take(aY,J)aY=jM(aY)return function()if J<1 then return end;local jW,jX=aY()if not jW then return end;J=J-1;return jW,jX end end;function bk.skip(aY,J)J=J or 1;for W=1,J do if aY()==nil then return bj{}end end;return aY end;function bk.enum(aY)local W=0;aY=jM(aY)return function()local jW,jX=aY()if not jW then return end;W=W+1;return W,jW,jX end end;function bk.mapmethod(aY,a5,dO,jY)aY=jM(aY)return function()local v=aY()if not v then return end;local bq=v[a5]if not bq then error(type(v).." does not have method "..a5)end;return bq(v,dO,jY)end end;function bk.last(aY)aY=jM(aY)local v,eu=aY(),nil;if v==nil then return bj{}end;return function()v,eu=aY(),v;if v==nil then return nil end;return v,eu end end;function bk.foreach(aY,bq)bq=aU(2,bq)for bg,bh,jZ in jM(aY)do bq(bg,bh,jZ)end end;local j_;local function k0(aY,...)if jK(aY)then return setmetatable({iter=aY},j_)else return aY,...end end;local bJ,aO,k1=bk.map,bk.reduce,bk.mapmethod;local k2={map=function(self,bn,a)return bJ(bn,self,a)end,reduce=function(self,bn,jV)return aO(bn,self,jV)end}j_={__index=function(dy,y)local bq=k2[y]or bk[y]if bq then return function(k3,...)return k0(bq(k3.iter,...))end else return function(k3,...)return k0(k1(k3.iter,y,...))end end end,__call=function(k3)return k3.iter()end}setmetatable(bk,{__call=function(dy,aY,m)if not jK(aY)then if type(aY)=='table'then aY=bk.list(aY)else return aY end end;if m then return setmetatable({iter=function()return aY(m)end},j_)else return setmetatable({iter=aY},j_)end end})function bk.lines(bp,...)local aY,a_;if bp=='STDIN'then bp=io.stdin elseif type(bp)=='string'then aY,a_=io.lines(bp,...)elseif not bp.read then error("Pass either a string or a file-like object",2)end;if not aY then aY,a_=bp:lines(...)end;if a_ then local gH,c5=aY,a_;aY=function()return gH(c5)end end;return k0(aY)end;function bk.import()debug.setmetatable(function()end,{__index=function(dy,y)local ak=k2[y]or bk[y]if ak then return ak else return function(ak,...)return bk.mapmethod(ak,y,...)end end end})end;return bk end end;do local _ENV=_ENV;package.preload["pl.sip"]=function(...)local a=_G.arg;local loadstring=rawget(_G,'loadstring')or load;local unpack=rawget(_G,'unpack')or rawget(table,'unpack')local N,aI=table.insert,table.concat;local ipairs,type=ipairs,type;local io,_G=io,_G;local print,rawget=print,rawget;local eO={FLOAT='[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',INTEGER='[+%-%d]%d*',IDEN='[%a_][%w_]*',OPTION='[%a_][%w_%-]*'}local function g(bi,v,hu)if type(v)~=hu then error("argument "..bi.." must be "..hu,2)end end;local gF={}local k4={['<']='>',['(']=')',['{']='}',['[']=']'}local k5={a=1,c=0,d=1,l=1,p=0,u=1,w=1,x=1,s=0}local function k6(ak)return'('..ak..')'end;local function k7(k8)return k8:gsub('[%-%.%+%[%]%(%)%^%%%?%*]','%%%0'):gsub('%$%%(%S)','$%1')end;local function k9(U)return U:gsub("()%s+()",function(bg,bh)local ka=U:sub(bg-2,bg-1)if ka:match('%$[vifadxlu]')or ka:match('^[^%$]?[%w_]$')then local kb=U:sub(bh,bh+1)if kb:match('%$[vifadxlu]')or kb:match('^[%w_]')then return'%s+'end end;return'%s*'end)end;local kc={v=k6(eO.IDEN),i=k6(eO.INTEGER),f=k6(eO.FLOAT),o=k6(eO.OPTION),r='(%S.*)',p='([%a]?[:]?[\\/%.%w_]+)'}function gF.custom_pattern(ht,U)kc[ht]=U end;function gF.create_pattern(k8,hV)g(1,k8,'string')local fg,kd={},{}if type(k8)=='string'then k8=k7(k8)else local K={}for W,ak in ipairs(k8)do K[W]=k7(ak)end;k8=aI(K,'.-')end;local ke=1;local function kf(a5,type)a5=a5 or ke;N(fg,a5)kd[a5]=type;ke=ke+1 end;local kg=k8:find('{%a+}')if hV and hV.at_start then k8='^'..k8 end;if k8:sub(-1,-1)=='$'then k8=k8:sub(1,-2)..'$r'if kg then k8=k8 ..'{rest}'end end;local kh;if kg then kh={}k8=k8:gsub('{(%a+)}',function(a5)N(kh,a5)return''end)end;k8=k9(k8)local bB=1;local bK;local cF=k8:gsub('%$%S',function(ak)local type,a5;type=ak:sub(2,2)if kh then a5=kh[bB]bB=bB+1 end;if not kh and type=='q'then kf(nil,'Q')else kf(a5,type)end;local K;if kc[type]then K=kc[type]elseif type=='q'then kf(a5,type)K='(["\'])(.-)%'..ke-2 else local ki=k4[type]if ki then K='(%b'..type..ki..')'elseif k5[type]or k5[type:lower()]then K='(%'..type..'+)'else bK="unknown format type or character class"end end;return K end)if bK then return nil,bK else return cF,fg,kd end end;local function kj(ak)return ak=='d'or ak=='i'or ak=='f'end;function gF.create_spec_fun(k8,hV)local kd,fg;local b3={}k8,fg,kd=gF.create_pattern(k8,hV)if not k8 then return k8,fg end;local kg=type(fg[1])=='string'for W=1,#fg do N(b3,'mm'..W)end;b3[1]=b3[1]or"mm1"local bn=('return (function(s,res)\n\tlocal %s = s:match(%q)\n'):format(aI(b3,','),k8)bn=bn..'\tif not mm1 then return false end\n'local bB=1;for W,bp in ipairs(fg)do if bp~='_'then local co='mm'..W;if kj(kd[bp])then co='tonumber('..co..')'elseif k4[kd[bp]]then co=co..':sub(2,-2)'end;if kg then bn=('%s\tres.%s = %s\n'):format(bn,bp,co)else if kd[bp]~='Q'then bn=('%s\tres[%d] = %s\n'):format(bn,bB,co)bB=bB+1 end end end end;return bn..'\treturn true\nend)\n',kg end;function gF.compile(k8,hV)g(1,k8,'string')local bn,kh=gF.create_spec_fun(k8,hV)if not bn then return nil,kh end;if rawget(_G,'_DEBUG')then print(bn)end;local dG,bK=loadstring(bn,'tmp')if bK then return nil,bK end;return dG(),kh end;local el={}function gF.match(k8,et,K,hV)g(1,k8,'string')g(2,et,'string')g(3,K,'table')if not el[k8]then el[k8]=gF.compile(k8,hV)end;return el[k8](et,K)end;function gF.match_at_start(k8,et,K)return gF.match(k8,et,K,{at_start=true})end;function gF.fields(k8,bp)g(1,k8,'string')if not bp then return nil,"no file object"end;local bn,bK=gF.compile(k8)if not bn then return nil,bK end;local K={}return function()while true do local et=bp:read()if not et then return end;if bn(et,K)then local g8=K;K={}return unpack(g8)end end end end;local kk={}function gF.pattern(k8,bn)g(1,k8,'string')local gC,kl=gF.compile(k8)N(kk,{pat=gC,named=kl,callback=bn})end;function gF.read(bp,i6)local km,bK;if not bp then return nil,"no file object"end;if type(bp)=='string'then bp,bK=io.open(bp)if not bp then return nil,bK end;km=true end;if i6 then for t,a0 in ipairs(i6)do gF.pattern(a0[1],a0[2])end end;local K={}for et in bp:lines()do for t,iU in ipairs(kk)do if iU.pat(et,K)then if iU.callback then if iU.named then iU.callback(K)else iU.callback(unpack(K))end end;K={}break end end end;if km then bp:close()end end;return gF end end;do local _ENV=_ENV;package.preload["pl.strict"]=function(...)local a=_G.arg;require'debug'local kn,error,rawset,rawget=debug.getinfo,error,rawset,rawget;local ko={}local function kp()local z=kn(3,"S")return z and z.what or"C"end;function ko.module(a5,gh,kq)local bA,kr,ks,kt,ku;if kq then ku=kq.__global end;if type(gh)=='table'then bA=getmetatable(gh)if bA and rawget(bA,'__declared')then return end else gh={}end;if bA==nil then bA={}setmetatable(gh,bA)else kr=bA.__newindex;ks=bA.__index;kt=type(ks)end;bA.__declared=kq or{}bA.__newindex=function(j,J,a4)if kr then kr(j,J,a4)if rawget(j,J)~=nil then return end end;if not bA.__declared[J]then if ku then local ah=kp()if ah~="main"and ah~="C"then error("assign to undeclared global '"..J.."'",2)end end;bA.__declared[J]=true end;rawset(j,J,a4)end;bA.__index=function(j,J)if not bA.__declared[J]and kp()~="C"then if ks then if kt=="table"then local kv=ks[J]if kv~=nil then return kv end else local K=ks(j,J)if K~=nil then return K end end end;local gR="variable '"..J.."' is not declared"if a5 then gR=gR.." in '"..tostring(a5).."'"end;error(gR,2)end;return rawget(j,J)end;return gh end;function ko.make_all_strict(bt)for bB,a4 in pairs(bt)do if type(a4)=='table'and a4~=bt then ko.module(bB,a4)end end end;function ko.closed_module(gh,a5)local ix={}gh=gh or{}local bA=getmetatable(gh)if not bA then bA={}setmetatable(gh,bA)end;bA.__newindex=function(j,bB,a4)ix[bB]=a4 end;return ko.module(a5,ix)end;if not rawget(_G,'PENLIGHT_NO_GLOBAL_STRICT')then ko.module(nil,_G,{_PROMPT=true,_PROMPT2=true,__global=true})end;return ko end end;do local _ENV=_ENV;package.preload["pl.stringio"]=function(...)local a=_G.arg;local unpack=rawget(_G,'unpack')or rawget(table,'unpack')local tonumber=tonumber;local aI,N=table.concat,table.insert;local kw={}local k0={}k0.__index=k0;local function kx(self,...)local ca={...}for W=1,#ca do N(self.tbl,ca[W])end end;function k0:write(dO,jY,...)if jY then kx(self,dO,jY,...)else N(self.tbl,dO)end end;function k0:writef(D,...)self:write(D:format(...))end;function k0:value()return aI(self.tbl)end;function k0:__tostring()return self:value()end;function k0:close()end;function k0:seek()end;local ky={}ky.__index=ky;function ky:_read(D)local W,a2=self.i,self.str;local i9=#a2;if W>i9 then return nil end;local K;if D=='*l'or D=='*L'then local bi=a2:find('\n',W)or i9+1;K=a2:sub(W,D=='*l'and bi-1 or bi)self.i=bi+1 elseif D=='*a'then K=a2:sub(W)self.i=i9 elseif D=='*n'then local t,bh,bi;t,bi=a2:find('%s*%d+',W)t,bh=a2:find('^%.%d+',bi+1)if bh then bi=bh end;t,bh=a2:find('^[eE][%+%-]*%d+',bi+1)if bh then bi=bh end;local v=a2:sub(W,bi)K=tonumber(v)self.i=bi+1 elseif type(D)=='number'then K=a2:sub(W,W+D-1)self.i=W+D else error("bad read format",2)end;return K end;function ky:read(...)if select('#',...)==0 then return self:_read('*l')else local K,kz={},{...}for W=1,#kz do K[W]=self:_read(kz[W])end;return unpack(K)end end;function ky:seek(kA,kB)local c1;kA=kA or'cur'kB=kB or 0;if kA=='set'then c1=1 elseif kA=='cur'then c1=self.i elseif kA=='end'then c1=#self.str end;self.i=c1+kB;return self.i end;function ky:lines(...)local J,ca=select('#',...)if J>0 then ca={...}end;return function()if J==0 then return self:_read'*l'else return self:read(unpack(ca))end end end;function ky:close()end;function kw.create()return setmetatable({tbl={}},k0)end;function kw.open(ak)return setmetatable({str=ak,i=1},ky)end;function kw.lines(ak,...)return kw.open(ak):lines(...)end;return kw end end;do local _ENV=_ENV;package.preload["pl.stringx"]=function(...)local a=_G.arg;local f=require'pl.utils'local string=string;local eW=string.find;local type,setmetatable,ipairs=type,setmetatable,ipairs;local error=error;local eQ=string.gsub;local dJ=string.rep;local bu=string.sub;local kC=string.reverse;local aI=table.concat;local N=table.insert;local k7=f.escape;local kD,d5=math.ceil,math.max;local g,eP=f.assert_arg,f.split;local gI;local function h(J,ak)g(J,ak,'string')end;local function kE(ak)return#ak>0 end;local function kF(J,ak)g(J,ak,'string',kE,'must be a non-empty string')end;local function aZ(eu)return setmetatable(eu,require('pl.List'))end;local e={}function e.isalpha(ak)h(1,ak)return eW(ak,'^%a+$')==1 end;function e.isdigit(ak)h(1,ak)return eW(ak,'^%d+$')==1 end;function e.isalnum(ak)h(1,ak)return eW(ak,'^%w+$')==1 end;function e.isspace(ak)h(1,ak)return eW(ak,'^%s+$')==1 end;function e.islower(ak)h(1,ak)return eW(ak,'^[%l%s]+$')==1 end;function e.isupper(ak)h(1,ak)return eW(ak,'^[%u%s]+$')==1 end;local function kG(ak,kH)return eW(ak,kH,1,true)==1 end;local function kI(ak,kJ)return#ak>=#kJ and eW(ak,kJ,#ak-#kJ+1,true)and true or false end;local function kK(ak,kL,bq)if type(kL)=='string'then return bq(ak,kL)elseif type(kL)=='table'then for t,kM in ipairs(kL)do if bq(ak,kM)then return true end end;return false else error(("argument #2 expected a 'string' or a 'table', got a '%s'"):format(type(kL)))end end;function e.startswith(ak,kH)h(1,ak)return kK(ak,kH,kG)end;function e.endswith(ak,kJ)h(1,ak)return kK(ak,kJ,kI)end;function e.join(ak,bk)h(1,ak)return aI(bk,ak)end;function e.splitlines(ak,kN)h(1,ak)local K={}local bO=1;while true do local kO=eW(ak,'[\r\n]',bO)if not kO then break end;local kP=bu(ak,kO,kO)if kP=='\r'and bu(ak,kO+1,kO+1)=='\n'then kP='\r\n'end;local et=bu(ak,bO,kO-1)if kN then et=et..kP end;N(K,et)bO=kO+#kP end;if bO<=#ak then N(K,bu(ak,bO))end;return aZ(K)end;function e.split(ak,en,J)h(1,ak)local dv=true;if not en then ak=gI(ak)dv=false end;local K=eP(ak,en,dv,J)if en and en~=''and eW(ak,en,-#en,true)and(J or math.huge)>#K then K[#K+1]=""end;return aZ(K)end;function e.expandtabs(ak,kQ)h(1,ak)kQ=kQ or 8;return ak:gsub("([^\t\r\n]*)\t",function(kR)return kR..(" "):rep(kQ-#kR%kQ)end)end;local function kS(ak,bu,ba,bb,kT)ba=ba or 1;bb=bb or#ak;if bu==''then return bb+1,bb-ba+1 end;local bg,bh=eW(ak,bu,ba,true)local K;local bB=0;while bg do if bb and bh>bb then break end;K=bg;bB=bB+1;if kT then bg,bh=eW(ak,bu,bg+1,true)else bg,bh=eW(ak,bu,bh+1,true)end end;return K,bB end;function e.lfind(ak,bu,ba,bb)h(1,ak)h(2,bu)local bg,bh=eW(ak,bu,ba,true)if bg and(not bb or bh<=bb)then return bg else return nil end end;function e.rfind(ak,bu,ba,bb)h(1,ak)h(2,bu)return kS(ak,bu,ba,bb,true)end;function e.replace(ak,kU,bW,J)h(1,ak)h(2,kU)h(3,bW)return eQ(ak,k7(kU),bW:gsub('%%','%%%%'),J)end;function e.count(ak,bu,kT)h(1,ak)local t,bB=kS(ak,bu,1,false,kT)return bB end;local function kV(ak,ah,X,kW,kX)local J=#ak;if ah>J then if not X then X=' 'end;local kY,kZ;if kW and kX then local k_=kD((ah-J)/2)local l0=ah-J-k_;kY=dJ(X,l0)kZ=dJ(X,k_)elseif kX then kY=dJ(X,ah-J)kZ=''else kZ=dJ(X,ah-J)kY=''end;return kY..ak..kZ else return ak end end;function e.ljust(ak,ah,X)h(1,ak)g(2,ah,'number')return kV(ak,ah,X,true,false)end;function e.rjust(ak,ah,X)h(1,ak)g(2,ah,'number')return kV(ak,ah,X,false,true)end;function e.center(ak,ah,X)h(1,ak)g(2,ah,'number')return kV(ak,ah,X,true,true)end;local function l1(ak,kW,kX,l2)if not l2 then l2='%s'else l2='['..k7(l2)..']'end;local bp=1;local j;if kW then local bg,bh=eW(ak,'^'..l2 ..'*')if bh>=bg then bp=bh+1 end end;if kX then if#ak<200 then local bg,bh=eW(ak,l2 ..'*$',bp)if bh>=bg then j=bg-1 end else local l3=kC(ak)local bg,bh=eW(l3,'^'..l2 ..'*')if bh>=bg then j=-bh-1 end end end;return bu(ak,bp,j)end;function e.lstrip(ak,l2)h(1,ak)return l1(ak,true,false,l2)end;gI=e.lstrip;function e.rstrip(ak,l2)h(1,ak)return l1(ak,false,true,l2)end;function e.strip(ak,l2)h(1,ak)return l1(ak,true,true,l2)end;function e.splitv(ak,en)h(1,ak)return f.splitv(ak,en)end;local function l4(a0,bl,bq)local bg,bh=bq(a0,bl)if not bg or bg==-1 then return a0,'',''else if not bh then bh=bg end;return bu(a0,1,bg-1),bu(a0,bg,bh),bu(a0,bh+1)end end;function e.partition(ak,X)h(1,ak)kF(2,X)return l4(ak,X,e.lfind)end;function e.rpartition(ak,X)h(1,ak)kF(2,X)local cm,cL,u=l4(ak,X,e.rfind)if cm==ak then return u,cL,cm end;return cm,cL,u end;function e.at(ak,bi)h(1,ak)g(2,bi,'number')return bu(ak,bi,bi)end;function e.lines(ak)h(1,ak)if not ak:find'\n$'then ak=ak..'\n'end;return ak:gmatch('([^\n]*)\n')end;function e.title(ak)h(1,ak)return ak:gsub('(%S)(%S*)',function(bp,cF)return bp:upper()..cF:lower()end)end;e.capitalize=e.title;local l5='...'local l6=#l5;function e.shorten(ak,ah,fZ)h(1,ak)if#ak>ah then if ah<l6 then return l5:sub(1,ah)end;if fZ then local W=#ak-ah+1+l6;return l5 ..ak:sub(W)else return ak:sub(1,ah-l6)..l5 end end;return ak end;local function l7(ak)local l8='([%[%]])(=*)%1'local l9,la,t;local be=1;repeat t,be,t,la=ak:find(l8,be)if la then l9=d5(l9 or 0,#la)end until not la;return l9 end;function e.quote_string(ak)h(1,ak)local lb=l7(ak.."]")if(ak:find("\n")or lb)and not ak:find("\r")then lb=("="):rep((lb or-1)+1)if ak:find("^\n")then ak="\n"..ak end;local lc,ld="["..lb.."[","]"..lb.."]"ak=lc..ak..ld else ak=("%q"):format(ak):gsub("\r","\\r")end;return ak end;function e.import()f.import(e,string)end;return e end end;do local _ENV=_ENV;package.preload["pl.tablex"]=function(...)local a=_G.arg;local f=require('pl.utils')local cp=require('pl.types')local getmetatable,setmetatable,require=getmetatable,setmetatable,require;local aJ,N,ct=table.sort,table.insert,table.remove;local ax=math.min;local pairs,type,unpack,select,tostring=pairs,type,f.unpack,select,tostring;local aU=f.function_arg;local g=f.assert_arg;local aK={}local function le(K,dy,lf)local bA=getmetatable(dy)or lf and require('pl.'..lf)return bA and setmetatable(K,bA)or K end;local function aZ(eu)return setmetatable(eu,require('pl.List'))end;local function lg(A)return setmetatable(A,require('pl.Map'))end;local function lh(bi,gR)error(('argument %d is not %s'):format(bi,gR),3)end;local function li(bi,v)if not cp.is_indexable(v)then lh(bi,"indexable")end end;local function lj(bi,v)if not cp.is_iterable(v)then lh(bi,"iterable")end end;local function lk(bi,v)if not cp.is_writeable(v)then lh(bi,"writeable")end end;function aK.update(bC,bD)lk(1,bC)lj(2,bD)for bB,a4 in pairs(bD)do bC[bB]=a4 end;return bC end;function aK.size(j)lj(1,j)local W=0;for bB in pairs(j)do W=W+1 end;return W end;function aK.copy(j)lj(1,j)local K={}for bB,a4 in pairs(j)do K[bB]=a4 end;return K end;local function ll(j,el)if type(j)~='table'then return j end;if el[j]then return el[j]end;lj(1,j)local K={}el[j]=K;local bA=getmetatable(j)for bB,a4 in pairs(j)do bB=ll(bB,el)a4=ll(a4,el)K[bB]=a4 end;setmetatable(K,bA)return K end;function aK.deepcopy(j)return ll(j,{})end;local lm=math.abs;local function ln(bC,bD,lo,bc,el)if el[bC]and el[bC][bD]then return true end;local lp=type(bC)local lq=type(bD)if lp~=lq then return false end;if lp~='table'then if lp=='number'and bc then return lm(bC-bD)<bc end;return bC==bD end;local bA=getmetatable(bC)if not lo and bA and bA.__eq then return bC==bD end;for lr in pairs(bC)do if bD[lr]==nil then return false end end;for ls in pairs(bD)do if bC[ls]==nil then return false end end;el[bC]=el[bC]or{}el[bC][bD]=true;for lr,jN in pairs(bC)do local jO=bD[lr]if not ln(jN,jO,lo,bc,el)then return false end end;return true end;function aK.deepcompare(bC,bD,lo,bc)return ln(bC,bD,lo,bc,{})end;function aK.compare(bC,bD,b7)li(1,bC)li(2,bD)if#bC~=#bD then return false end;b7=aU(3,b7)for bB=1,#bC do if not b7(bC[bB],bD[bB])then return false end end;return true end;function aK.compare_no_order(bC,bD,b7)li(1,bC)li(2,bD)if b7 then b7=aU(3,b7)end;if#bC~=#bD then return false end;local lt={}for W=1,#bC do local v=bC[W]local lu;for cC=1,#bD do if not lt[cC]then local gG;if b7 then gG=b7(v,bD[cC])else gG=v==bD[cC]end;if gG then lu=cC;break end end end;if not lu then return false end;lt[lu]=true end;return true end;function aK.find(j,v,bi)li(1,j)bi=bi or 1;if bi<0 then bi=#j+bi+1 end;for W=bi,#j do if j[W]==v then return W end end;return nil end;function aK.rfind(j,v,bi)li(1,j)bi=bi or#j;if bi<0 then bi=#j+bi+1 end;for W=bi,1,-1 do if j[W]==v then return W end end;return nil end;function aK.find_if(j,b7,a)lj(1,j)b7=aU(2,b7)for bB,a4 in pairs(j)do local u=b7(a4,a)if u then return bB,u end end;return nil end;function aK.index_by(dy,bi)li(1,dy)li(2,bi)local K={}for W=1,#bi do K[W]=dy[bi[W]]end;return le(K,dy,'List')end;function aK.map(bn,j,...)lj(1,j)bn=aU(1,bn)local K={}for bB,a4 in pairs(j)do K[bB]=bn(a4,...)end;return le(K,j)end;function aK.imap(bn,j,...)li(1,j)bn=aU(1,bn)local K={}for W=1,#j do K[W]=bn(j[W],...)or false end;return le(K,j,'List')end;function aK.map_named_method(a5,j,...)f.assert_string(1,a5)li(2,j)local K={}for W=1,#j do local v=j[W]local bn=v[a5]K[W]=bn(v,...)end;return le(K,j,'List')end;function aK.transform(bn,j,...)lj(1,j)bn=aU(1,bn)for bB,a4 in pairs(j)do j[bB]=bn(a4,...)end end;function aK.range(bd,be,lv)local K;lv=lv or 1;if bd==be then K={bd}elseif bd>be and lv>0 or be>bd and lv<0 then K={}else local bB=1;K={}for W=bd,be,lv do K[bB]=W;bB=bB+1 end end;return aZ(K)end;function aK.map2(bn,bC,bD,...)lj(1,bC)lj(2,bD)bn=aU(1,bn)local K={}for bB,a4 in pairs(bC)do K[bB]=bn(a4,bD[bB],...)end;return le(K,bC,'List')end;function aK.imap2(bn,bC,bD,...)li(2,bC)li(3,bD)bn=aU(1,bn)local K,J={},math.min(#bC,#bD)for W=1,J do K[W]=bn(bC[W],bD[W],...)end;return K end;function aK.reduce(bn,j,lw)li(2,j)bn=aU(1,bn)local J=#j;if J==0 then return lw end;local K=lw and bn(lw,j[1])or j[1]for W=2,J do K=bn(K,j[W])end;return K end;function aK.foreach(j,bn,...)lj(1,j)bn=aU(2,bn)for bB,a4 in pairs(j)do bn(a4,bB,...)end end;function aK.foreachi(j,bn,...)li(1,j)bn=aU(2,bn)for W=1,#j do bn(j[W],W,...)end end;function aK.mapn(bn,...)bn=aU(1,bn)local K={}local lx={...}local ly=1e40;for W=1,#lx do ly=ax(ly,#lx[W])end;for W=1,ly do local ca,bB={},1;for cC=1,#lx do ca[bB]=lx[cC][W]bB=bB+1 end;K[#K+1]=bn(unpack(ca))end;return K end;function aK.pairmap(bn,j,...)lj(1,j)bn=aU(1,bn)local K={}for bB,a4 in pairs(j)do local lz,lA=bn(bB,a4,...)if lA then if K[lA]then if type(K[lA])=='table'then table.insert(K[lA],lz)else K[lA]={K[lA],lz}end else K[lA]=lz end else K[#K+1]=lz end end;return K end;local function lB(W,a4)return W end;function aK.keys(j)lj(1,j)return aZ(aK.pairmap(lB,j))end;local function lC(W,a4)return a4 end;function aK.values(j)lj(1,j)return aZ(aK.pairmap(lC,j))end;local function lD(W,a4)return W,a4 end;function aK.index_map(j)li(1,j)return lg(aK.pairmap(lD,j))end;local function lE(W,a4)return true,a4 end;function aK.makeset(j)li(1,j)return setmetatable(aK.pairmap(lE,j),require('pl.Set'))end;function aK.merge(bC,bD,lF)lj(1,bC)lj(2,bD)local K={}for bB,a4 in pairs(bC)do if lF or bD[bB]then K[bB]=a4 end end;if lF then for bB,a4 in pairs(bD)do K[bB]=a4 end end;return le(K,bC,'Map')end;function aK.union(bC,bD)return aK.merge(bC,bD,true)end;function aK.intersection(bC,bD)return aK.merge(bC,bD,false)end;function aK.difference(bY,bZ,lG)lj(1,bY)lj(2,bZ)local K={}for bB,a4 in pairs(bY)do if bZ[bB]==nil then K[bB]=a4 end end;if lG then for bB,a4 in pairs(bZ)do if bY[bB]==nil then K[bB]=a4 end end end;return le(K,bY,'Map')end;function aK.count_map(j,b7)li(1,j)local K,lH={},{}b7=aU(2,b7 or'==')local J=#j;for W=1,#j do local a4=j[W]if not lH[a4]then lH[a4]=true;K[a4]=1;for cC=W+1,J do local ah=j[cC]local aF=b7(a4,ah)if aF then K[a4]=K[a4]+1;lH[ah]=true end end end end;return lg(K)end;function aK.filter(j,e9,a)li(1,j)e9=aU(2,e9)local K,bB={},1;for W=1,#j do local a4=j[W]if e9(a4,a)then K[bB]=a4;bB=bB+1 end end;return le(K,j,'List')end;function aK.zip(...)return aK.mapn(function(...)return{...}end,...)end;local lI;function lI(db,b2,lJ,lK,lL,lM)lJ=lJ or 1;lK=lK or 1;local lN;if not lL then lL=#b2;lN=#b2 else lN=lK+ax(lL-1,#b2-lK)end;if db==b2 then if lJ>lK and lN>=lJ then b2=aK.sub(b2,lK,lL)lK=1;lN=#b2 end end;for W=lK,lN do db[lJ]=b2[W]lJ=lJ+1 end;if lM then aK.clear(db,lJ)end;return db end;function aK.icopy(db,b2,lJ,lK,lL)li(1,db)li(2,b2)return lI(db,b2,lJ,lK,lL,true)end;function aK.move(db,b2,lJ,lK,lL)li(1,db)li(2,b2)return lI(db,b2,lJ,lK,lL,false)end;function aK._normalize_slice(self,ba,bb)local i9=#self;if not ba then ba=1 end;if ba<0 then ba=i9+ba+1 end;if not bb then bb=i9 end;if bb<0 then bb=i9+1+bb end;return ba,bb end;function aK.sub(j,ba,bb)li(1,j)ba,bb=aK._normalize_slice(j,ba,bb)local K={}for W=ba,bb do N(K,j[W])end;return le(K,j,'List')end;function aK.set(j,v,bg,bh)li(1,j)bg,bh=bg or 1,bh or#j;if cp.is_callable(v)then for W=bg,bh do j[W]=v(W)end else for W=bg,bh do j[W]=v end end end;function aK.new(J,v)local K={}aK.set(K,v,1,J)return K end;function aK.clear(j,lO)lO=lO or 1;for W=lO,#j do ct(j)end end;function aK.insertvalues(j,...)g(1,j,'table')local bO,g8;if select('#',...)==1 then bO,g8=#j+1,...else bO,g8=...end;if#g8>0 then for W=#j,bO,-1 do j[W+#g8]=j[W]end;local kB=1-bO;for W=bO,bO+#g8-1 do j[W]=g8[W+kB]end end;return j end;function aK.removevalues(j,bg,bh)g(1,j,'table')bg,bh=aK._normalize_slice(j,bg,bh)for W=bg,bh do ct(j,bg)end;return j end;local lP;lP=function(j,bN,jm)for bB,a4 in pairs(j)do if a4==bN then return bB end end;for bB,a4 in pairs(j)do if not jm[a4]and type(a4)=='table'then jm[a4]=true;local K=lP(a4,bN,jm)if K then K=tostring(K)if type(bB)~='string'then return'['..bB..']'..K else return bB..'.'..K end end end end end;function aK.search(j,bN,lQ)lj(1,j)local jm={[j]=true}if lQ then for t,a4 in pairs(lQ)do jm[a4]=true end end;return lP(j,bN,jm)end;function aK.sort(j,bp)local bG={}for bB in pairs(j)do bG[#bG+1]=bB end;aJ(bG,bp)local W=0;return function()W=W+1;return bG[W],j[bG[W]]end end;function aK.sortv(j,bp)bp=aU(2,bp or'<')local bG={}for bB in pairs(j)do bG[#bG+1]=bB end;aJ(bG,function(b5,L)return bp(j[b5],j[L])end)local W=0;return function()W=W+1;return bG[W],j[bG[W]]end end;function aK.readonly(j)local bA={__index=j,__newindex=function(j,bB,a4)error("Attempt to modify read-only table",2)end,__pairs=function()return pairs(j)end,__ipairs=function()return ipairs(j)end,__len=function()return#j end,__metatable=false}return setmetatable({},bA)end;return aK end end;do local _ENV=_ENV;package.preload["pl.template"]=function(...)local a=_G.arg;local f=require'pl.utils'local N,jI,gp,go,lR=table.insert,string.format,string.sub,string.find,string.gsub;local lS="\n__R_size = __R_size + 1; __R_table[__R_size] = "local function lT(lU,dG,lV,d8)local ak=1;for lW,lX,dK in dG:gmatch(lV)do lX='('..gp(lX,2,-2)..')'N(lU,lS..jI("%q",gp(dG,ak,lW-1)))N(lU,lS..jI("__tostring(%s or '')",lX))ak=dK end;local cF;if d8 then cF=jI("%q",lR(gp(dG,ak),"\n",""))else cF=jI("%q",gp(dG,ak))end;if cF~='""'then N(lU,lS..cF)end end;local function lY(dG,lZ,k4,l_,d8)local lV="()"..lZ.."(%b"..k4 ..")()"local m0=l_.."+([^\n]*\n?)"local m1,m2="^"..m0,"\n"..m0;local lU,ak={"return function()\nlocal __R_size, __R_table, __tostring = 0, {}, __tostring",n=1},1;while true do local t,dK,m3=go(dG,m1,ak)if not dK then local m4;m4,dK,m3=go(dG,m2,ak)lT(lU,gp(dG,ak,m4),lV,d8)if not dK then break end end;if gp(m3,-1,-1)=="\n"then m3=gp(m3,1,-2)end;N(lU,"\n"..m3)ak=dK+1 end;N(lU,"\nreturn __R_table\nend")local h2=false;if#lU==3 and lU[2]:find(lS,1,true)==1 then lU={"return "..lU[2]:sub(#lS+1,-1)}h2=true end;return table.concat(lU),h2 end;local m5={}function m5.substitute(a2,dz)dz=dz or{}local j,bK=m5.compile(a2,{chunk_name=rawget(dz,"_chunk_name"),escape=rawget(dz,"_escape"),inline_escape=rawget(dz,"_inline_escape"),inline_brackets=rawget(dz,"_brackets"),newline=nil,debug=rawget(dz,"_debug")})if not j then return j,bK end;return j:render(dz,rawget(dz,"_parent"),rawget(dz,"_debug"))end;local m6=function(self,dz,m7,m8)dz=dz or{}if m7 then setmetatable(dz,{__index=m7})end;setmetatable(self.env,{__index=dz})local K,cA=xpcall(self.fn,debug.traceback)if not K then if self.code and m8 then print(self.code)end;return nil,cA,self.code end;return table.concat(cA),nil,self.code end;function m5.compile(a2,gy)gy=gy or{}local m9=gy.chunk_name or'TMP'local k7=gy.escape or'#'local lZ=gy.inline_escape or'$'local ma=gy.inline_brackets or'()'local eg,h2=lY(a2,lZ,ma,k7,gy.newline)local dz={__tostring=tostring}local bq,bK=f.load(eg,m9,'t',dz)if not bq then return nil,bK,eg end;if h2 then local mb=bq()return{fn=bq(),env=dz,render=function(self)return mb,nil,self.code end,code=gy.debug and eg or nil}end;return{fn=bq(),env=dz,render=m6,code=gy.debug and eg or nil}end;return m5 end end;do local _ENV=_ENV;package.preload["pl.test"]=function(...)local a=_G.arg;local aK=require'pl.tablex'local f=require'pl.utils'local ja=require'pl.pretty'local b_=require'pl.path'local type,unpack,fI=type,f.unpack,f.pack;local mc=os.clock;local debug=require'debug'local io=io;local function md(b5)if type(b5)=='table'and not(getmetatable(b5)and getmetatable(b5).__tostring)then return ja.write(b5,' ',true)elseif type(b5)=='string'then return'"'..b5 ..'"'else return tostring(b5)end end;local me={}function me.error_handler(c5,et,mf,mg,gR)local bK=io.stderr;bK:write(b_.basename(c5)..':'..et..': assertion failed\n')bK:write("got:\t",mf,'\n')bK:write("needed:\t",mg,'\n')f.quit(1,gR or"these values were not equal")end;local function lh(b5,L,gR,mh)local W=debug.getinfo(3+(mh or 0))me.error_handler(W.short_src,W.currentline,md(b5),md(L),gR)end;me.complain=lh;function me.asserteq(b5,L,bc,mh)local K=b5==L;if not K then K=aK.deepcompare(b5,L,true,bc)end;if not K then lh(b5,L,nil,mh)end end;function me.assertmatch(bY,bZ,mh)if not bY:match(bZ)then lh(bY,bZ,"these strings did not match",mh)end end;function me.assertraise(bq,dK,mh)local aF,bK;if type(bq)=='table'then aF,bK=pcall(unpack(bq))else aF,bK=pcall(bq)end;if aF or bK:match(dK)==nil then lh(bK,dK,"these errors did not match",mh)end end;function me.asserteq2(mi,mj,mk,ml,mh)if mi~=mk then lh(mi,mk,nil,mh)end;if mj~=ml then lh(mj,ml,nil,mh)end end;local mm={unpack=unpack}mm.__index=mm;function mm.__tostring(self)local p={}for W=1,self.n do local ak=self[W]p[W]=type(ak)=='string'and('%q'):format(ak)or tostring(ak)end;return'tuple('..table.concat(p,', ')..')'end;function mm.__eq(cm,cL)if cm.n~=cL.n then return false end;for W=1,cm.n do if cm[W]~=cL[W]then return false end end;return true end;function mm.__len(self)return self.n end;function me.tuple(...)return setmetatable(fI(...),mm)end;function me.timer(gR,J,bn,...)local bd=mc()for W=1,J do bn(...)end;f.printf("%s: took %7.2f sec\n",gR,mc()-bd)end;return me end end;do local _ENV=_ENV;package.preload["pl.text"]=function(...)local a=_G.arg;local eQ=string.gsub;local aI,N=table.concat,table.insert;local f=require'pl.utils'local mn,eP,g=f.bind1,f.split,f.assert_arg;local mo=require'pl.types'.is_callable;local unpack=f.unpack;local mp={}local function aZ(eu)return setmetatable(eu,require('pl.List'))end;local function gI(a2)return a2:gsub('^%s+','')end;local function ep(a2)return gI(a2):gsub('%s+$','')end;local function aT(ak,bl)return aZ(eP(ak,bl))end;local function aM(bp,j,...)local K={}for W=1,#j do K[W]=bp(j[W],...)end;return K end;local function mq(ak,mr)local ms=aT(ak,'\n')return aI(aM(mn('..',mr),ms),'\n')..'\n'end;function mp.indent(ak,J,X)g(1,ak,'string')g(2,J,'number')return mq(ak,string.rep(X or' ',J))end;function mp.dedent(ak)g(1,ak,'string')local ms=aT(ak,'\n')local t,bh=(#ms>0 and ms[1]or''):find('^%s*')ms=aM(string.sub,ms,bh+1)return aI(ms,'\n')..'\n'end;function mp.wrap(ak,mt)g(1,ak,'string')mt=mt or 70;ak=ak:gsub('\n',' ')local W,aA=1;local gH,et={}while W<#ak do aA=W+mt;if ak:find("[%w']",aA)then aA=ak:find('%W',aA+1)end;et=ak:sub(W,aA)W=W+#et;N(gH,ep(et))end;return aZ(gH)end;function mp.fill(ak,mt)return aI(mp.wrap(ak,mt),'\n')..'\n'end;local mu={}mp.Template=mu;mu.__index=mu;setmetatable(mu,{__call=function(a_,mv)return mu.new(mv)end})function mu.new(mv)g(1,mv,'string')local K={}K.tmpl=mv;setmetatable(K,mu)return K end;local function mw(ak,dy,mx)local my;if mo(dy)then my=dy else function my(bp)local ak=dy[bp]if not ak then if mx then return bp else error("not present in table "..bp)end else return ak end end end;local K=eQ(ak,'%${([%w_]+)}',my)return eQ(K,'%$([%w_]+)',my)end;function mu:substitute(dy)g(1,dy,'table')return mw(self.tmpl,dy,false)end;function mu:safe_substitute(dy)g(1,dy,'table')return mw(self.tmpl,dy,true)end;function mu:indent_substitute(dy)g(1,dy,'table')if not self.strings then self.strings=aT(self.tmpl,'\n')end;local function my(et)return et:gsub('(%s*)%$([%w_]+)',function(mr,bp)local mz;local ak=dy[bp]if not ak then error("not present in table "..bp)end;if getmetatable(ak)==mu then mz=ak;ak=ak.tmpl else ak=tostring(ak)end;if ak:find'\n'then ak=mq(ak,mr)end;if mz then return mw(ak,dy)else return ak end end)end;local gH=aM(my,self.strings)return aI(gH,'\n')..'\n'end;function mp.format_operator()local jI=string.format;local function mA(D,...)local ca={...}local W=1;for a0 in D:gmatch('%%.')do if a0=='%s'and type(ca[W])~='string'then ca[W]=tostring(ca[W])end;W=W+1 end;return jI(D,unpack(ca))end;local function mB(ak,j)return ak:gsub('%$([%w_]+)',j)end;getmetatable("").__mod=function(cm,cL)if cL==nil then return cm elseif type(cL)=="table"and getmetatable(cL)==nil then if#cL==0 then return mw(cm,cL,true)else return mA(cm,unpack(cL))end elseif type(cL)=='function'then return mB(cm,cL)else return mA(cm,cL)end end end;return mp end end;do local _ENV=_ENV;package.preload["pl.types"]=function(...)local a=_G.arg;local f=require'pl.utils'local mC=math.ceil;local g=f.assert_arg;local cp={}function cp.is_callable(a_)return type(a_)=='function'or getmetatable(a_)and getmetatable(a_).__call and true end;cp.is_type=f.is_type;local mD=getmetatable(io.stdout)function cp.type(a_)local j=type(a_)if j=='table'or j=='userdata'then local bA=getmetatable(a_)if bA==mD then return'file'elseif bA==nil then return j else return bA._name or"unknown "..j end else return j end end;function cp.is_integer(b5)return mC(b5)==b5 end;function cp.is_empty(mE,mF)if mE==nil then return true elseif type(mE)=="table"then return next(mE)==nil elseif type(mE)=="string"then return mE==""or not not mF and not not mE:find("^%s+$")else return true end end;local function mG(v)if type(v)=='table'then return true end;return getmetatable(v)end;function cp.is_indexable(v)local bA=mG(v)if bA==true then return true end;return bA and bA.__len and bA.__index and true end;function cp.is_iterable(v)local bA=mG(v)if bA==true then return true end;return bA and bA.__pairs and true end;function cp.is_writeable(v)local bA=mG(v)if bA==true then return true end;return bA and bA.__newindex and true end;local mH={yes=true,y=true,["true"]=true,t=true,["1"]=true}local mI={boolean=function(mE,mJ,mK)return mE end,string=function(mE,mJ,mK)mE=mE:lower()if mH[mE]then return true end;for t,a4 in ipairs(mJ or{})do if type(a4)=="string"and mE==a4:lower()then return true end end;return false end,number=function(mE,mJ,mK)return mE~=0 end,table=function(mE,mJ,mK)if mK and next(mE)~=nil then return true end;return false end}function cp.to_bool(mE,mJ,mK)local mL;if mJ then g(2,mJ,"table")end;mL=mI[type(mE)]if mL then return mL(mE,mJ,mK)elseif mK and mE~=nil then return true end;return false end;return cp end end;do local _ENV=_ENV;package.preload["pl.url"]=function(...)local a=_G.arg;local mM={}local function mN(u)return string.format("%%%02X",string.byte(u))end;function mM.quote(ak,mO)if type(ak)~="string"then return ak end;ak=ak:gsub("\n","\r\n")ak=ak:gsub("([^A-Za-z0-9 %-_%./])",mN)if mO then ak=ak:gsub(" ","+")ak=ak:gsub("/",mN)else ak=ak:gsub(" ","%%20")end;return ak end;local function mP(G)return string.char(tonumber(G,16))end;function mM.unquote(ak)if type(ak)~="string"then return ak end;ak=ak:gsub("+"," ")ak=ak:gsub("%%(%x%x)",mP)ak=ak:gsub("\r\n","\n")return ak end;return mM end end;do local _ENV=_ENV;package.preload["pl.utils"]=function(...)local a=_G.arg;local jI=string.format;local dh=require'pl.compat'local cx=io.stdout;local N=table.insert;local mQ=table.unpack;local mR=dh.is_windows;local mS='default'local bL;local mT;local mU={}local f={_VERSION="1.11.0"}for bB,a4 in pairs(dh)do f[bB]=a4 end;f.patterns={FLOAT='[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',INTEGER='[+%-%d]%d*',IDEN='[%a_][%w_]*',FILE='[%a%.\\][:%][%w%._%-\\]*'}f.stdmt={List={_name='List'},Map={_name='Map'},Set={_name='Set'},MultiMap={_name='MultiMap'}}f.pack=table.pack;function f.unpack(j,W,cC)return mQ(j,W or 1,cC or j.n or#j)end;function f.printf(D,...)f.assert_string(1,D)f.fprintf(cx,D,...)end;function f.fprintf(bp,D,...)f.assert_string(2,D)bp:write(jI(D,...))end;do local function mV(bt,bB,a4,mW)local y=rawget(bt,bB)if y and bB~='_M'and bB~='_NAME'and bB~='_PACKAGE'and bB~='_VERSION'then f.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",mW,bB)return end;rawset(bt,bB,a4)end;local function mX(bt,j)for bB,a4 in pairs(bt)do if a4==j then return bB end end;return'?'end;local mY={}function f.import(j,bt)bt=bt or _G;j=j or f;if type(j)=='string'then j=require(j)end;local mW=mX(bt,j)if mY[j]then return end;mY[j]=mW;for bB,a4 in pairs(j)do mV(bt,bB,a4,mW)end end end;function f.choose(mZ,m_,n0)return mZ and m_ or n0 end;function f.array_tostring(j,n1,n2)n1,n2=n1 or{},n2 or tostring;for W=1,#j do n1[W]=n2(j[W],W)end;return n1 end;function f.is_type(a_,hu)if type(hu)=='string'then return type(a_)==hu end;local bA=getmetatable(a_)return hu==bA end;function f.assert_arg(J,v,hu,n3,gR,n4)if type(v)~=hu then error(("argument %d expected a '%s', got a '%s'"):format(J,hu,type(v)),n4 or 2)end;if n3 and not n3(v)then error(("argument %d: '%s' %s"):format(J,v,gR),n4 or 2)end;return v end;function f.function_arg(bi,bp,gR)f.assert_arg(1,bi,'number')local hu=type(bp)if hu=='function'then return bp end;if hu=='string'then if not mT then mT=require'pl.operator'.optable end;local bq=mT[bp]if bq then return bq end;local bq,bK=f.string_lambda(bp)if not bq then error(bK..': '..bp)end;return bq elseif hu=='table'or hu=='userdata'then local bA=getmetatable(bp)if not bA then error('not a callable object',2)end;local n5=mU[bA]if not n5 then if not bA.__call then error('not a callable object',2)end;return bp else return n5(bp)end end;if not gR then gR=" must be callable"end;if bi>0 then error("argument "..bi..": "..gR,2)else error(gR,2)end end;function f.assert_string(J,v)return f.assert_arg(J,v,'string',nil,nil,3)end;function f.on_error(dF)dF=tostring(dF)if({['default']=1,['quit']=2,['error']=3})[dF]then mS=dF else local bK="Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(dF).."'"if mS=='default'then error(bK,2)end;bL(bK)end end;function f.raise(bK)if mS=='default'then return nil,bK elseif mS=='quit'then return f.quit(bK)else error(bK,2)end end;bL=f.raise;function f.readfile(jy,n6)local dF=n6 and'b'or''f.assert_string(1,jy)local bp,n7=io.open(jy,'r'..dF)if not bp then return bL(n7)end;local K,n8=bp:read('*a')bp:close()if not K then return bL(jy..": "..n8)end;return K end;function f.writefile(jy,a2,n6)local dF=n6 and'b'or''f.assert_string(1,jy)f.assert_string(2,a2)local bp,bK=io.open(jy,'w'..dF)if not bp then return bL(bK)end;local aF,n9=bp:write(a2)bp:close()if not aF then return bL(jy..": "..n9)end;return true end;function f.readlines(jy)f.assert_string(1,jy)local bp,bK=io.open(jy,'r')if not bp then return bL(bK)end;local K={}for et in bp:lines()do N(K,et)end;bp:close()return K end;function f.executeex(cb,na)local fG=os.tmpname()local nb=os.tmpname()if mR and not fG:find(':')then fG=os.getenv('TEMP')..fG;nb=os.getenv('TEMP')..nb end;cb=cb.." > "..f.quote_arg(fG).." 2> "..f.quote_arg(nb)local h6,nc=f.execute(cb)local nd=f.readfile(fG,na)local ne=f.readfile(nb,na)os.remove(fG)os.remove(nb)return h6,nc,nd or"",ne or""end;function f.quote_arg(nf)if type(nf)=="table"then local cF={}for W,a in ipairs(nf)do cF[W]=f.quote_arg(a)end;return table.concat(cF," ")end;if mR then if nf==""or nf:find('[ \f\t\v]')then nf='"'..nf:gsub([[(\*)"]],[[%1%1\"]]):gsub([[\+$]],"%0%0")..'"'end;return nf:gsub('["^<>!|&%%]',"^%0")else if nf==""or nf:find('[^a-zA-Z0-9_@%+=:,./-]')then nf="'"..nf:gsub("'",[['\'']]).."'"end;return nf end end;function f.quit(eg,gR,...)if type(eg)=='string'then f.fprintf(io.stderr,eg,gR,...)io.stderr:write('\n')eg=-1 elseif gR then f.fprintf(io.stderr,gR,...)io.stderr:write('\n')end;os.exit(eg,true)end;function f.escape(ak)f.assert_string(1,ak)return ak:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1')end;function f.split(ak,en,dv,J)f.assert_string(1,ak)local eW,bu,N=string.find,string.sub,table.insert;local bg,b3=1,{}if not en then en='%s+'end;if en==''then return{ak}end;while true do local bh,jZ=eW(ak,en,bg,dv)if not bh then local bb=bu(ak,bg)if bb~=''then N(b3,bb)end;if#b3==1 and b3[1]==''then return{}else return b3 end end;N(b3,bu(ak,bg,bh-1))if J and#b3==J then b3[#b3]=bu(ak,bg)return b3 end;bg=jZ+1 end end;function f.splitv(ak,en,dv,J)return mQ(f.split(ak,en,dv,J))end;function f.memoize(fJ)local el={}return function(bB)local K=el[bB]if K==nil then K=fJ(bB)el[bB]=K end;return K end end;function f.add_function_factory(bA,bn)mU[bA]=bn end;local function ng(bp)if bp:find'^|'or bp:find'_'then local ca,nh=bp:match'|([^|]*)|(.+)'if bp:find'_'then ca='_'nh=bp else if not ca then return bL'bad string lambda'end end;local g9='return function('..ca..') return '..nh..' end'local bq,bK=f.load(g9)if not bq then return bL(bK)end;bq=bq()return bq else return bL'not a string lambda'end end;f.string_lambda=f.memoize(ng)function f.bind1(bq,a0)bq=f.function_arg(1,bq)return function(...)return bq(a0,...)end end;function f.bind2(bq,a0)bq=f.function_arg(1,bq)return function(b5,...)return bq(b5,a0,...)end end;do local ni=function(gR,nj)if nj then warn(gR,"\n",nj)else warn(gR)end end;function f.set_deprecation_func(fJ)if fJ==nil then ni=function()end else f.assert_arg(1,fJ,"function")ni=fJ end end;function f.raise_deprecation(gy)f.assert_arg(1,gy,"table")if type(gy.message)~="string"then error("field 'message' of the options table must be a string",2)end;local nj;if not gy.no_trace then nj=debug.traceback("",2):match("[\n%s]*(.-)$")end;local gR;if gy.deprecated_after and gy.version_removed then gR=(" (deprecated after %s, scheduled for removal in %s)"):format(tostring(gy.deprecated_after),tostring(gy.version_removed))elseif gy.deprecated_after then gR=(" (deprecated after %s)"):format(tostring(gy.deprecated_after))elseif gy.version_removed then gR=(" (scheduled for removal in %s)"):format(tostring(gy.version_removed))else gR=""end;gR=gy.message..gR;if gy.source then gR="["..gy.source.."] "..gR else if gR:sub(1,1)=="@"then error("message cannot start with '@'",2)end end;ni(gR,nj)end end;return f end end;do local _ENV=_ENV;package.preload["pl.xml"]=function(...)local a=_G.arg;local f=require'pl.utils'local aT=f.split;local eo=table.insert;local nk=table.concat;local nl=table.remove;local nm=string.match;local tostring=tostring;local setmetatable=setmetatable;local getmetatable=getmetatable;local pairs=pairs;local ipairs=ipairs;local type=type;local next=next;local print=print;local unpack=f.unpack;local nn=string.gsub;local no=string.find;local pcall,require,io=pcall,require,io;local np={}local nq={__type="doc"}nq.__index=nq;function np.new(nr,ns)local nt={tag=nr,attr=ns or{},last_add={}}return setmetatable(nt,nq)end;function np.parse(nu,nv,nw)local nx,dP,ny;if nw then nx=np.basic_parse else dP,ny=pcall(require,'lxp.lom')if not dP then nx=np.basic_parse else nx=ny.parse end end;if nv then local bp,bK=io.open(nu)if not bp then return nil,bK end;nu=bp:read'*a'bp:close()end;local nt,bK=nx(nu)if not nt then return nil,bK end;if ny then np.walk(nt,false,function(t,z)setmetatable(z,nq)end)end;return nt end;function nq:addtag(nr,nz)local ak=np.new(nr,nz)(self.last_add[#self.last_add]or self):add_direct_child(ak)eo(self.last_add,ak)return self end;function nq:text(mp)(self.last_add[#self.last_add]or self):add_direct_child(mp)return self end;function nq:up()nl(self.last_add)return self end;function nq:reset()local nA=self.last_add;for W=1,#nA do nA[W]=nil end;return self end;function nq:add_direct_child(nB)eo(self,nB)end;function nq:add_child(nB)(self.last_add[#self.last_add]or self):add_direct_child(nB)return self end;function nq:set_attribs(j)for bB,a4 in pairs(j)do self.attr[bB]=a4 end end;function nq:set_attrib(cm,a4)self.attr[cm]=a4 end;function nq:get_attribs()return self.attr end;local function nC(ak)return type(ak)=='string'end;function np.elem(nr,nD)local ak=np.new(nr)if nC(nD)then nD={nD}end;if np.is_tag(nD)then eo(ak,nD)elseif type(nD)=='table'then for bB,a4 in pairs(nD)do if nC(bB)then ak.attr[bB]=a4;eo(ak.attr,bB)else ak[bB]=a4 end end end;return ak end;function np.tags(bj)local nE={}if nC(bj)then bj=aT(bj,'%s*,%s*')end;for t,nr in ipairs(bj)do local nF=function(nD)return np.elem(nr,nD)end;eo(nE,nF)end;return unpack(nE)end;local nG={}local function nH(nI)if nC(nI)then if nG[nI]then nI=nG[nI]else local a2,bK=nI;nI,bK=np.parse(a2,false,true)if not nI then return nil,bK end;nG[a2]=nI end elseif not np.is_tag(nI)then return nil,"template is not a document"end;return nI end;local function nJ(eR)return#eR==0 or type(eR[1])~='table'end;local function nK(eR)for W,a4 in ipairs(eR)do eR[tostring(W)]=a4 end end;function nq.subst(nI,eR)local bK;if type(eR)~='table'or not next(eR)then return nil,"data must be a non-empty table"end;if nJ(eR)then nK(eR)end;nI,bK=nH(nI)if bK then return nil,bK end;local function nL(iU)return np.clone(nI,function(ak)return ak:gsub('%$(%w+)',iU)end)end;if nJ(eR)then return nL(eR)end;local bj={}for t,iU in ipairs(eR)do nK(iU)eo(bj,nL(iU))end;if eR.tag then bj=np.elem(eR.tag,bj)end;return bj end;function nq:child_with_name(nr)for t,nB in ipairs(self)do if nB.tag==nr then return nB end end end;local nM;function nM(self,nr,bj,nN)for t,nB in ipairs(self)do if type(nB)=='table'then if nB.tag==nr then eo(bj,nB)end;if nN then nM(nB,nr,bj,nN)end end end end;function nq:get_elements_with_name(nr,nO)local K={}nM(self,nr,K,not nO)return K end;function nq:children()local W=0;return function(cm)W=W+1;return cm[W]end,self,W end;function nq:first_childtag()if#self==0 then return end;for t,j in ipairs(self)do if type(j)=='table'then return j end end end;function nq:matching_tags(nr,nP)nP=nP or self.attr.xmlns;local nQ=self;local nR,nS,a4=1,#nQ;return function()for W=nR,nS do a4=nQ[W]if(not nr or a4.tag==nr)and(not nP or nP==a4.attr.xmlns)then nR=W+1;return a4 end end end,nQ,nR end;function nq:childtags()local W=0;return function(cm)local a4;repeat W=W+1;a4=self[W]if a4 and type(a4)=='table'then return a4 end until not a4 end,self[1],W end;function nq:maptags(nT)local nU=np.is_tag;local W=1;while W<=#self do if nU(self[W])then local c9=nT(self[W])if c9==nil then nl(self,W)else self[W]=c9;W=W+1 end end end;return self end;local nV;do local nW={["'"]="&apos;",["\""]="&quot;",["<"]="&lt;",[">"]="&gt;",["&"]="&amp;"}function nV(a2)return nn(a2,"['&<>\"]",nW)end;np.xml_escape=nV end;local function nX(j,nY,self,nV,nZ,n_,jt,o0)local o1=0;local nr=j.tag;local o2,o3=""," "if jt then o2='\n'..n_ end;if o0 then o3='\n'..n_..o0 end;eo(nY,o2 .."<"..nr)local function o4(bB,a4)if no(bB,"\1",1,true)then local ap,o5=nm(bB,"^([^\1]*)\1?(.*)$")o1=o1+1;eo(nY," xmlns:ns"..o1 .."='"..nV(ap).."' ".."ns"..o1 ..":"..o5 .."='"..nV(a4).."'")elseif not(bB=="xmlns"and a4==nZ)then eo(nY,o3 ..bB.."='"..nV(a4).."'")end end;if#j.attr>0 then for t,bB in ipairs(j.attr)do o4(bB,j.attr[bB])end else for bB,a4 in pairs(j.attr)do o4(bB,a4)end end;local o6,o7=#j;if o6==0 then local cA="/>"if o0 then cA='\n'..n_..cA end;eo(nY,cA)else eo(nY,">")for J=1,o6 do local nB=j[J]if nB.tag then self(nB,nY,self,nV,j.attr.xmlns,n_ and n_..jt,jt,o0)o7=true else eo(nY,nV(nB))end end;eo(nY,(o7 and o2 or'').."</"..nr..">")end end;function np.tostring(j,n_,jt,o0,o8)local nY={}if o8 then if type(o8)=="string"then nY[1]=o8 else nY[1]="<?xml version='1.0'?>"end end;nX(j,nY,nX,nV,nil,n_,jt,o0)return nk(nY)end;nq.__tostring=np.tostring;function nq:get_text()local K={}for W,o9 in ipairs(self)do if nC(o9)then eo(K,o9)end end;return nk(K)end;function np.clone(nt,oa)local ob={}local function lI(oc,an,m7)if type(oc)~="table"then if oa and nC(oc)then return oa(oc,an,m7)else return oc end elseif ob[oc]then return ob[oc]end;local od={}ob[oc]=od;local nr=oc.tag;od.tag=lI(nr,'*TAG',m7)if oc.attr then local K={}for ns,bN in pairs(oc.attr)do K[ns]=lI(bN,ns,oc)end;od.attr=K end;for cB=1,#oc do local a4=lI(oc[cB],'*TEXT',oc)eo(od,a4)end;return setmetatable(od,getmetatable(oc))end;return lI(nt)end;nq.filter=np.clone;function np.compare(bC,bD)local lp=type(bC)local lq=type(bD)if lp~=lq then return false,'type mismatch'end;if lp=='string'then return bC==bD and true or'text '..bC..' ~= text '..bD end;if lp~='table'or lq~='table'then return false,'not a document'end;if bC.tag~=bD.tag then return false,'tag  '..bC.tag..' ~= tag '..bD.tag end;if#bC~=#bD then return false,'size '..#bC..' ~= size '..#bD..' for tag '..bC.tag end;for bB,a4 in pairs(bC.attr)do if bD.attr[bB]~=a4 then return false,'mismatch attrib'end end;for bB,a4 in pairs(bD.attr)do if bC.attr[bB]~=a4 then return false,'mismatch attrib'end end;for W=1,#bC do local oe,bK=np.compare(bC[W],bD[W])if not oe then return bK end end;return true end;function np.is_tag(z)return type(z)=='table'and nC(z.tag)end;function np.walk(nt,of,og)if not of then og(nt.tag,nt)end;for t,z in ipairs(nt)do if np.is_tag(z)then np.walk(z,of,og)end end;if of then og(nt.tag,nt)end end;local oh={br=true,img=true,meta=true,frame=true,area=true,hr=true,base=true,col=true,link=true,input=true,option=true,param=true,isindex=true,embed=true}local oi={quot="\"",apos="'",lt="<",gt=">",amp="&"}local function oj(a2)return a2:gsub("&(%a+);",oi)end;function np.parsehtml(ak)return np.basic_parse(ak,false,true)end;function np.basic_parse(ak,ok,ol)local eo,nl=table.insert,table.remove;local no,om=string.find,string.sub;local iG={}local on={}local function oo(ak)local a={}ak:gsub("([%w:%-_]+)%s*=%s*([\"'])(.-)%2",function(ah,t,cm)if ol then ah=ah:lower()end;a[ah]=oj(cm)end)if ol then ak:gsub("([%w:%-_]+)%s*=%s*([^\"']+)%s*",function(ah,cm)ah=ah:lower()a[ah]=oj(cm)end)end;return a end;eo(iG,on)local op,u,oq,ot,ou,t,lO;local W=1;local cC;t,lO=no(ak,'^%s*<%?[^%?]+%?>%s*')if not lO then t,lO=no(ak,'^%s*<!DOCTYPE.->%s*')end;if lO then W=lO+1 end;while true do op,cC,u,oq,ot,ou=no(ak,"<([%/!]?)([%w:%-_]+)(.-)(%/?)>",W)if not op then break end;if u=="!"then if not(oq:match'%-%-$'and ot=='')then if ot:match'%-%-$'then cC=cC-2 end;t,cC=no(ak,"-->",cC,true)end else local mp=om(ak,W,op-1)if ol then oq=oq:lower()if oh[oq]then ou="/"end end;if ok or not no(mp,"^%s*$")then eo(on,oj(mp))end;if ou=="/"then eo(on,setmetatable({tag=oq,attr=oo(ot),empty=1},nq))elseif u==""then on=setmetatable({tag=oq,attr=oo(ot)},nq)eo(iG,on)else local ov=nl(iG)on=iG[#iG]if#iG<1 then error("nothing to close with "..oq..':'..mp)end;if ov.tag~=oq then error("trying to close "..ov.tag.." with "..oq.." "..mp)end;eo(on,ov)end end;W=cC+1 end;local mp=om(ak,W)if ok or not no(mp,"^%s*$")then eo(iG[#iG],oj(mp))end;if#iG>1 then error("unclosed "..iG[#iG].tag)end;local K=iG[1]return nC(K[1])and K[2]or K[1]end;local function ou(ns)return not ns or not next(ns)end;local function ow(z)return type(z)=='table'and z.tag~=nil end;local function ox(j)local y,bN=next(j)if next(j,y)~=nil then return false end;return y,bN end;local function oy(K,dy)if not ou(dy)then local y;if dy._ then y=dy._;dy._=nil;if ou(dy)then return end end;local jj,v=ox(dy)if jj==0 then dy=v end;if y then K[y]=dy else eo(K,dy)end end end;local function oz(gC)if gC:find'^%d+$'then gC=tonumber(gC)end;return gC end;local function oA(K,gC,bN)gC=oz(gC:sub(2))K[gC]=bN;return true end;local gG;function gG(z,gC,K,oB)local c9=true;if z==nil then z=''end;if nC(z)then if not nC(gC)then return false end;if np.debug then print(z,gC)end;if gC:find'^%$'then return oA(K,gC,z)else return z==gC end else if np.debug then print(z.tag,gC.tag)end;local oC=gC.tag:match'^(.-)%-$'if oC then oC=oz(oC)K[oC]=z.tag end;if z.tag==gC.tag or oC then if not ou(gC.attr)then if ou(z.attr)then c9=false else for oD,oE in pairs(gC.attr)do local oF=z.attr[oD]if not gG(oF,oE,K)then c9=false;break end end end end;if c9 and#gC>0 then local W,cC=1,1;local function oG()cC=cC+1;if nC(z[cC])then cC=cC+1 end;return cC<=#z end;repeat local a0=gC[W]if ow(a0)and a0.repeated then local gn;repeat local dy={}c9=gG(z[cC],a0,dy,false)if c9 then gn=false;oy(K,dy)end until not oG()or gn and not c9;W=W+1 else c9=gG(z[cC],a0,K,false)if c9 then W=W+1 end end until not oG()or W>#gC;if W>#gC then return true end end;if c9 then return true end else c9=false end;if oB then for nB in z:childtags()do c9=gG(nB,gC,K,oB)if c9 then break end end end end;return c9 end;function nq:match(gC)local bK;gC,bK=nH(gC)if not gC then return nil,bK end;np.walk(gC,false,function(t,z)if nC(z[1])and ow(z[2])and nC(z[3])and z[1]:find'%s*{{'and z[3]:find'}}%s*'then nl(z,1)nl(z,2)z[1].repeated=true end end)local K={}local c9=gG(self,gC,K,true)return K,c9 end;return np end end
